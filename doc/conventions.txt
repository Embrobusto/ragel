
***********************************************************************
                         AAPL Documentation
                         ------------------

                            Conventions
                            -----------

                             March 2002
                          Adrian Thurston
***********************************************************************


This document will describe repeated patterns that occur in aapl.
Reading this document should enable a developer to make reasonably good
guesses about how to properly use aapl data structures without reading
the full docs on the aapl component.


                              CONTENTS

1. Inheritance, Templates, and the Preprocessor
  1.1 By-Simple-Value Templates
  1.2 By-Structure Templates
  1.3 One Class Source, Many Flavours.

2. Class Members
  2.1 Data Members
  2.2 Function Members

3. Iterators

4. Compare Classes



              1. INHERITANCE, TEMPLATES, AND THE PREPROCESSOR
              ***********************************************

Aapl uses inheritance and templates together in order to make versatile
structures. For example, elements can exist in more than one structure
at the same time. Also, elements need not be allocated on the heap. Using
inheritance and templates together usually looks like:

struct MyElement : public BaseElementType<MyElement>
{
    // Element customizations here.
    int data;
};

The element inherits the data fields required for the data structure
and passes to the inherited class it its own name, so the inherited data
fields can be pointers to the user's element.

With a linked list, the above is the same as doing:

struct MyElement
{
    MyElement *prev, *next;
    // Element customizations here.
    int data;
};

The advantage is that multiple inheritance can be used to make MyStruct
multiple double list elements. Or multiple AvlTree elements.

Aapl enables the preprocessor to provide many different flavours of
each data structure that though are the exact same code, but have slight
variations in how they are used. For example, what happens when you add
an item to a list? Is a new element newed up automatically and a pointer
to my data assigned to in the element? Or do I supply the storage for
the element. This question is answered by having different flavours.

1.1 By-Simple-Value Templates
=============================

The flavours of aapl data structres can be divided into two groups. The
first of which is the By-Simple-Value type. This type is 


1.2 By-Structure Templates
==========================

1.3 One Class Source, Many Flavours
===================================


                          2. CLASS MEMBERS
                          ****************

2.1 Data Members
================
<coming soon>

2.2 Function Members
====================


cont.append( item )    Put a new item at then end of the sequence.

cont.prepend( item )   Put a new item at the beginning of the sequence.

cont.detach( item )    Remove an item from the container but do not delete it.
                       Vector based containers do not support detach as they
                       implicitly manage the memory used by the objects they 
                       contain in one continuous chunk.

cont.remove( item )    Remove an item from the container and delete it.

cont.abandon()         Abandon all items in the container. Afterwards the container
                       is empty and no items are deleted.

cont.empty()           Empty out the container and delete items. Afterwards the
                       container is empty and all items are deleted.


                           2. ITERATORS
                           ************
<coming soon>
