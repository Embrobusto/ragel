
***********************************************************************
                         AAPL Documentation
                         ------------------

                              Vector
                              ------

                             Feb 2002
                          Adrian Thurston
***********************************************************************


                              CONTENTS

1. Overview
  1.1 Introduction
  1.2 Quick Usage Examples
  1.3 Allocation Schemes

2. Vector Flavours
  2.1 Table of Vector Flavours

3. Common Vector
  3.1 Constructors & Destructors
  3.2 empty
  3.3 insert
  3.4 remove
  3.5 replace
  3.6 setAs
  3.7 append
  3.8 prepend
  3.9 Data Members


                              1. VECTOR
                              *********

1.1 Introduction
================

This is typical vector implementation. It is a dynamic array that can
be used to contain complex data structures that have constructors and
destructors as well as simple types such as integers and pointers.

Vector provides automatic resizing of allocated memory as needed and
offers many different allocation schemes for controlling how the automatic
allocation is done.

It supports inserting, removing, and replacing single or multiple elements
at once. Constructors and destructors are called wherever appropriate.
For example, before an element is overwritten, it's destructor is called.

Two senses of the the length of the data is maintained: the amount of
raw memory allocated to the vector and the number of actual elements
in the vector. The various allocation schemes control how the allocated
space is changed in relation to the number of elements in the vector.


1.2 Quick Usage Examples
========================

How to use vector with the default memory allocation scheme:

Example One:
-----------------------------------
#include "vector.h"

int main()
{
    Vector<int> v;
    v.append( 1 );

    /* Inserts 10 element at pos 0 with no initialization */
    v.insert( 0, 0, 5 ); 

    return 0;
}
-----------------------------------

Example Two:
-----------------------------------
#include <iostream>
#include "vector.h"

class Element
{
public:
    Element() : data(0) { cout << "Default Constructor" << endl; }
    Element(const Element &o) : data(o.data) { cout << "Copy Constructor" << endl; }
    Element(int data) : data(data) { cout << "Initialization Constructor" << endl; }
    ~Element() { cout << "Destructor" << endl; }
    int data;
};

int main()
{
    Vector<Element> v;
    v.append( Element(2) );

    /* Inserts 5 element at pos 0 with default constructor */
    v.insert( 0, 0, 5 );      

    return 0;
}
-----------------------------------



1.3 Allocation Schemes
======================

Vector manages resizing the vector up and resizing the vector down. For
each direction there are three schemes to choose from. This gives 3x3=9
vectors to choose from plus a 10th vector that lets the user set and
change the allocation schemes at run time.

The three schemes are:

1) Exponential
 In the up direction, if more space is needed than available, then
 double the amount needed is allocated. In the down direction, if less
 than a quarter of the space allocated is used then double the amount
 needed is allocated. The result is that when growing the vector in a
 linear fashion, the number of resizes of the allocated space behaves
 logarithmically.
 

2) Linear
 In the up direction, if more space is needed than available, then the
 amount needed plus some step is allocated. In the down direction, if
 less than the current allocation minus twice the step is needed, then the
 amount need plus the step is allocated. The result is that when growing
 the vector in a linear fashion, the number of resizes is also linear.

3) Constant
 Don't change the allocation upon up changing the size.


In 1) and 2) more space than needed is kept when resizing down. This
guarantees that when using Exponential for both up and down or Linear for
both up and down, repetitive inserting and removing of a small number of
elements (relative to the size of the array in the Exponential case and
relative to the step in the Linear case) will never result in repetative
reallocation of the space needed.


                             2. FLAVOURS
                             ***********

2.1 Table of Vector Flavours
============================

    Vector Name     Header         Down Resizing      Up Resizing
    -------------------------------------------------------------
    Vector          vector.h       Exponential        Exponential
    VectorE         vectore.h      Exponential        Exponential
    VectorEL        vectorel.h     Exponential        Linear
    VectorEC        vectorec.h     Exponential        Constant
    VectorLE        vectorle.h     Linear             Exponential
    VectorL         vectorl.h      Linear             Linear
    VectorLC        vectorlc.h     Linear             Constant
    VectorCE        vectorce.h     Constant           Exponential
    VectorCL        vectorcl.h     Constant           Linear
    VectorC         vectorc.h      Constant           Constant
    VectorR         vectorr.h      Run-Time           Run-Time


                          3. COMMON VECTOR
                          ****************

The different flavours of the vector share the same interface except
for a few differences between the available constructors. In the case
of the linear vector, it is desirable to be able to set the step by
which the allocation is resized. In the case of the runtime vector,
constructors exist to set the allocation schemes.


NAME
    void prepend(const T *val, int len);

DESCRIPTION
    Prepend len elements to the front of the vector. Copy constructors
    are used to place the elements in the vector. If val is NULL
    then the new elements are initialized with default constructors.

NAME
    void prepend(const Vector &v);

DESCRIPTION
    Prepend the contents of vector v to the front of the vector. Copy
    constructors are used to place the elements in the vector.

3.9 Data Members
================

NAME
    T *table;

DESCRIPTION
    The pointer to the elements in the vector. Modifying the vector
    may cause this pointer to change.

NAME
    int tableLenth

DESCRIPTION
    The number of items in the vector.
    
NAME
    int allocLength

DESCRIPTION
    The number of items for which there is room in the current
    allocation.

