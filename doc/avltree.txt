
***********************************************************************
                         AAPL Documentation
                         ------------------

                             Avl Tree
                             --------

                             Feb 2002
                          Adrian Thurston
***********************************************************************


                              CONTENTS

1. Overview
  1.1 Introduction
  1.2 Quick Usage Instructions
  1.3 Characteristics
  1.4 AvlTree vs. Binary Search Table

2. Avl Elements
  2.1 Requirements to be a Element
  2.2 Example

3. Flavours
  3.1 Comparison



                             1. AVL TREE
                             ***********

1.1 Introduction
================

Avl Tree is a balanced binary tree. Regular binary trees can suffer
performance issues when items are inserted in sorted order. Balanced
trees correct this problem by guaranteeing an evenly distributed tree
regardless of the order in which items are inserted. Avl is just one of
many mechansims for balancing trees.

Like Binary Search Table, Avl Tree can be used to implement a map.
However, there are important differences between the two data
structures. In some cases avl tree is more appropriate and in others
binary search table is more appropriate.

1.2 Quick Usage Example
=======================

How to use an avl tree in the most common way: as a map that can be
iterated.

----------------------------
#include <iostream>
#include "avlimap.h"

int main()
{
    AvliMap<char *, int, StrCmp> avlmap;
    AvliMapEl<char*, int> *element;

    /* Insert. */
    avlmap.insert( "the first key", 1 );
    avlmap.insert( "the second key", 2 );

    /* Find. */
    element = avlmap.find( "the first key" );

    /* Iterate. */
    for ( element = avlmap.head; element != 0; element = element->next )
        cout << element->key << ", " << element->value << endl;
    
    /* Delete */
    delete avlmap.detach( "the second key" );

    return 0;
}
----------------------------


1.3 Characteristics
===================

All operations are O(log(N)). This means that in a tree with thirty-two
thousand elements, at most 16 comparisons are needed to find an
element. In practice, the avl tree may need to do two or three more
because attaining a perfectly level tree is not possible.

Elements in a tree are individually allocated by the user of the tree.
With the exception of AvlMap and AvlSet, the user generally goes

    avltree.insert( new Element(...) );

where the Element is a class that contains the necessary pointers needed
by the Avl algorithms, the key that is used to compare items, the compare
routine itself and any other user data. In short, any class can become a
element that goes into an avl tree by inheriting from the right classes.

It is also possible to have the tree allocate the element on behalf of the
user, in which case the element class must have an appropriate constructor.

    avltree.insert( "the key" );

Elements can be elements in multiple trees by inheriting from multiple
AvlTreeEl base structures (which contain the left, right and parent
pointers, etc.) and specifying to the tree template how to resolve
the ambiguities.

This implementation of avl tree cannot contain duplicate keys. It cannot
be used to directly implement a so called multi-map. Binary search table
does support inserting duplicate keys. Of course an avl tree could be
used to store lists of elements in order to accomplish a multi-map,
though this is not provided by aapl.

Avl tree solves the common map problem of inserting elements under the
condition that they are not already there by allowing the currently
existing element to be returned from an insert operation that fails.

AvlTree supports the maintainance of an ordered list of the elements
without adding more than a constant amount of work to each operation. It
is easy to walk the list of items in the tree by simply using the next
and prev pointers in the element.

1.4 Avl Tree vs. Binary Search Table
====================================

                     |    Avl Tree        |    Binary Search Table
======================================================================
Inserting            |    O(log(N))       |    O(N)
---------------------|--------------------|---------------------------
Removing             |    O(log(N))       |    O(N)
---------------------|--------------------|---------------------------
Finding              |    O(log(N))       |    O(log(N))
---------------------|--------------------|---------------------------
Element Allocation   |    individual      |    array
---------------------|--------------------|---------------------------
Element Allocation   |    mostly manual   |    automatic
Management           |                    |
---------------------|--------------------|---------------------------
Safe to Reference    |    yes             |    no
Elements while       |                    |
Structure Changes    |                    |
---------------------|--------------------|---------------------------
Supports an Ordered  |    yes             |    yes
Walk of Elements     |                    |
---------------------|--------------------|---------------------------
Duplicate Keys       |    no              |    yes


                           2. AVL TREE ELEMENTS
                           *****************

2.1 Requirements to be a Element
=============================

This section applies to all trees except AvlMap and AvlSet, which do
not require you to make your own element class. They come with element.

An avl element must have:
- The avl tree pointers obtained by inheriting AvlTreeEl (or AvliTreeEl).
- A key of any type.
- The standardized getKey routine so the tree can retrieve the key
  without knowing what it is called.
- A static compare routine that operates on the key type.

An avl element should have:
- A constructor that takes the key type as a single arg if the
  AvlTree::insert(const Key &key) function is instantiated.
- A copy constructor if the tree copy constructor is instantiated.

2.2 Example
===========

-----------------------------------------------------------------
#include "avltree.h"

struct CustomEl :
        public AvlTreeEl<CustomEl>
{
    /* Used by insert(const Key &key) function. */
    CustomEl(const int &key) :
            key(key) { }

    /* Used by the tree copy constructor. */
    CustomEl(const CustomEl &other) : 
            key(other.key), data(other.data) { }

    /* Returns the key. The refernce to the type is optional, but
     * advised when the key is a non-simple type such as a vector or 
     * a large class. */
    const int &getKey() { return key; }
    static inline int Compare( const int &k1, const int &k2 );

    int key;
    int data;
};

int CustomEl::Compare( const int &k1, const int &k2 )
{
    if ( k1 < k2 )
        return -1;
    else if ( k1 > k2 )
        return 1;
    else
        return 0;
}
-----------------------------------------------------------------

There are some standard compare classes available in compare.h that can
be inherited by the CustomEl structure, so it is not always necessary
to make a Compare routine.

                             3. FLAVOURS
                             ***********

There are 5 flavours of the avl tree. Each flavour is also available
in a walkable version. The walkable trees maintain next and previous
pointers in each element and have the Avli prefix.

3.1 Comparison
==============

    Tree Name     Header        Iterate    Element       Element in 
                                           Supplied   Multiple Trees
    ------------------------------------------------------------------------------
    AvlTree       avltree.h     no         no         no
    AvlMel        avlmel.h      no         no         yes
    AvlMelKey     avlmelkey.h   no         no         yes (with distinct keys)
    AvlMap        avlmap.h      no         yes        N/A
    AvlSet        avlset.h      no         yes        N/A
    AvliTree      avlitree.h    yes        no         no
    AvliMel       avlimel.h     yes        no         yes
    AvliMelKey    avlimelkey.h  yes        no         yes (with distinct keys)
    AvliMap       avlimap.h     yes        yes        N/A
    AvliSet       avliset.h     yes        yes        N/A
