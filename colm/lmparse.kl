/*
 *  Copyright 2006-2012 Adrian Thurston <thurston@complang.org>
 */

/*  This file is part of Colm.
 *
 *  Colm is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 * 
 *  Colm is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License
 *  along with Colm; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */

#include <iostream>
#include <errno.h>

#include "config.h"
#include "lmparse.h"
#include "global.h"
#include "input.h"

using std::cout;
using std::cerr;
using std::endl;

ParserDict parserDict;

void ColmParser::init()
{
	/* Set up the root namespace. */
	Namespace *rootNamespace = createNamespace(
			internal, String("___ROOT_NAMESPACE") );
	pd->rootNamespace = rootNamespace;

	TokenRegion *rootRegion = createRegion( internal );

	RegionSet *rootRegionSet = new RegionSet( rootRegion, 0, 0, 0 );
	pd->regionSetList.append( rootRegionSet );
	regionStack.push( rootRegionSet );

	pd->rootRegion = rootRegion;

	/* Set up the global object. */
	String global = "global";
	pd->globalObjectDef = ObjectDef::cons( ObjectDef::UserType,
			global, pd->nextObjectId++ ); 
	
	/* The eofTokenRegion defaults to the root region. */
	pd->eofTokenRegion = rootRegion;

	/* Initialize the dictionary of graphs. This is our symbol table. The
	 * initialization needs to be done on construction which happens at the
	 * beginning of a machine spec so any assignment operators can reference
	 * the builtins. */
	pd->initGraphDict();

	pd->rootLocalFrame = ObjectDef::cons( ObjectDef::FrameType, 
				"local", pd->nextObjectId++ );
	pd->curLocalFrame = pd->rootLocalFrame;

	initPda();
}

void ColmParser::addRegularDef( const InputLoc &loc, Namespace *nspace,
		const String &name, LexJoin *join )
{
	GraphDictEl *newEl = nspace->rlMap.insert( name );
	if ( newEl != 0 ) {
		/* New element in the dict, all good. */
		newEl->value = new LexDefinition( name, join );
		newEl->isInstance = false;
		newEl->loc = loc;
	}
	else {
		// Recover by ignoring the duplicate.
		error(loc) << "regular definition \"" << name << "\" already exists" << endl;
	}
}

TokenRegion *ColmParser::createRegion( const InputLoc &loc )
{
	TokenRegion *tokenRegion = new TokenRegion( loc,
			pd->regionList.length() );

	pd->regionList.append( tokenRegion );

	/* New element in the dict, all good. */
	RegionDef *regionDef = new RegionDef( tokenRegion, loc );
	pd->regionDefList.append( regionDef );

	return tokenRegion;
}

void ColmParser::pushRegionSet( const InputLoc &loc )
{
	TokenRegion *tokenIgnore = createRegion( loc );
	TokenRegion *tokenOnly = createRegion( loc );
	TokenRegion *ignoreOnly = createRegion( loc );
	TokenRegion *collectIgnore = createRegion( loc );

	RegionSet *regionSet = new RegionSet( tokenIgnore,
			tokenOnly, ignoreOnly, collectIgnore );

	tokenIgnore->ignoreOnlyRegion = ignoreOnly;
	tokenIgnore->tokenOnlyRegion = tokenOnly;
	tokenIgnore->ciRegion = collectIgnore;

	tokenIgnore->isFullRegion = true;
	ignoreOnly->isIgnoreOnly = true;
	collectIgnore->isCiOnly = true;
	tokenOnly->isTokenOnly = true;

	ignoreOnly->derivedFrom = tokenIgnore;
	collectIgnore->derivedFrom = tokenIgnore;
	tokenOnly->derivedFrom = tokenIgnore;

	pd->regionSetList.append( regionSet );
	regionStack.push( regionSet );
}

void ColmParser::popRegionSet()
{
	regionStack.pop();
}

Namespace *ColmParser::createNamespace( const InputLoc &loc, const String &name )
{
	Namespace *parentNamespace = namespaceStack.length() > 0 ?
			namespaceStack.top() : 0;

	/* Make the new namespace. */
	Namespace *nspace = new Namespace( loc, name,
			pd->namespaceList.length(), parentNamespace );

	if ( parentNamespace != 0 )
		parentNamespace->childNamespaces.append( nspace );

	pd->namespaceList.append( nspace );
	namespaceStack.push( nspace );

	return nspace;
}

int ColmParser::token( InputLoc &loc, int tokId, char *tokstart, int toklen )
{
	Token token;

	if ( toklen > 0 )
		token.data.setAs( tokstart, toklen );

	token.loc = loc;
	int res = parseLangEl( tokId, &token );
	if ( res < 0 ) {
		parse_error(tokId, token) << "parse error" << endl;
		exit(1);
	}
	return res;
}

LexJoin *ColmParser::literalJoin( const InputLoc &loc, const String &data )
{
	Literal *literal = Literal::cons( loc, data, Literal::LitString );
	LexFactor *factor = LexFactor::cons( literal );
	LexFactorNeg *factorNeg = LexFactorNeg::cons( loc, factor );
	LexFactorRep *factorRep = LexFactorRep::cons( loc, factorNeg );
	LexFactorAug *factorAug = LexFactorAug::cons( factorRep );
	LexTerm *term = LexTerm::cons( factorAug );
	LexExpression *expr = LexExpression::cons( term );
	LexJoin *join = LexJoin::cons( expr );
	return join;
}

void ColmParser::tokenInstance( const InputLoc &loc, String name, LexJoin *join,
		CodeBlock *transBlock, bool ignore, bool noPreIgnore, bool noPostIgnore )
{
	/* Check the region if this is for an ignore. */
	if ( ignore && !pd->insideRegion )
		error(loc) << "ignore tokens can only appear inside scanners" << endp;

	/* Check the name if this is a token. */
	if ( !ignore && name == 0 )
		error(loc) << "tokens must have a name" << endp;

	/* Give a default name to ignores. */ 
	if ( name == 0 )
		name.setAs( 32, "_ignore_%.4x", pd->nextTokenId );

	Namespace *nspace = namespaceStack.top();
	RegionSet *regionSet = regionStack.top();

	TokenDef *tokenDef = TokenDef::cons( name, String(), false, ignore, join, 
			transBlock, loc, 0, nspace, regionSet->tokenIgnore,
			&reCaptureVect, curObjectDef,
			contextStack.top() );

	regionSet->tokenDefList.append( tokenDef );
	nspace->tokenDefList.append( tokenDef );

	tokenDef->noPreIgnore = noPreIgnore;
	tokenDef->noPostIgnore = noPostIgnore;

	TokenInstance *tokenInstance = TokenInstance::cons( tokenDef,
			join, loc, pd->nextTokenId++, nspace, 
			regionSet->tokenIgnore, &reCaptureVect );

	regionSet->tokenIgnore->tokenInstanceList.append( tokenInstance );
	nspace->tokenInstanceList.append( tokenInstance );

	tokenDef->noPreIgnore = noPreIgnore;
	tokenDef->noPostIgnore = noPostIgnore;

	if ( ignore ) {
		/* The instance for the ignore-only. */
		TokenInstance *tokenInstanceIgn = TokenInstance::cons( tokenDef,
				join, loc, pd->nextTokenId++, nspace, regionSet->ignoreOnly,
				&reCaptureVect );

		tokenInstanceIgn->dupOf = tokenInstance;

		regionSet->ignoreOnly->tokenInstanceList.append( tokenInstanceIgn );
		nspace->tokenInstanceList.append( tokenInstanceIgn );
	}
	else {
		/* The instance for the token-only. */
		TokenInstance *tokenInstanceTok = TokenInstance::cons( tokenDef,
				join, loc, pd->nextTokenId++, nspace, regionSet->tokenOnly,
				&reCaptureVect );

		tokenInstanceTok->dupOf = tokenInstance;

		regionSet->tokenOnly->tokenInstanceList.append( tokenInstanceTok );
		nspace->tokenInstanceList.append( tokenInstanceTok );
	}

	/* This is created and pushed in the name. */
	if ( !pd->insideRegion )
		popRegionSet();

	if ( join != 0 ) {
		/* Create a regular language definition so the token can be used to
		 * make other tokens */
		addRegularDef( loc, namespaceStack.top(), name, join );
	}

	reCaptureVect.empty();
}

void ColmParser::zeroDef( const InputLoc &loc, const String &data,
		bool noPreIgnore, bool noPostIgnore )
{
	/* Create a name for the literal. */
	String name( 32, "_literal_%.4x", pd->nextTokenId );

	bool insideRegion = regionStack.length() > 1;
	if ( !insideRegion )
		error(loc) << "zero token should be inside token" << endp;

	String interp("");;

	/* Look for the production's associated region. */
	Namespace *nspace = namespaceStack.top();
	RegionSet *regionSet = regionStack.top();

	LiteralDictEl *ldel = nspace->literalDict.find( interp );
	if ( ldel != 0 )
		error( loc ) << "literal already defined in this namespace" << endp;

	LexJoin *join = literalJoin( loc, data );

	TokenDef *tokenDef = TokenDef::cons( name, data, true, false, join, 
			0, loc, 0, nspace, regionSet->tokenIgnore, 0, 0, 0 );

	tokenDef->isZero = true;

	regionSet->tokenDefList.append( tokenDef );
	nspace->tokenDefList.append( tokenDef );

	TokenInstance *tokenInstance = TokenInstance::cons( tokenDef, join, 
			loc, pd->nextTokenId++, nspace, regionSet->tokenIgnore, 0 );

	/* Doesn't go into instance list. */

	ldel = nspace->literalDict.insert( interp, tokenInstance );
	nspace->tokenInstanceList.append( tokenInstance );
}

void ColmParser::literalDef( const InputLoc &loc, const String &data,
		bool noPreIgnore, bool noPostIgnore )
{
	/* Create a name for the literal. */
	String name( 32, "_literal_%.4x", pd->nextTokenId );

	bool insideRegion = regionStack.length() > 1;
	if ( !insideRegion )
		pushRegionSet( loc );

	bool unusedCI;
	String interp;
	prepareLitString( interp, unusedCI, data, loc );

	/* Look for the production's associated region. */
	Namespace *nspace = namespaceStack.top();
	RegionSet *regionSet = regionStack.top();

	LiteralDictEl *ldel = nspace->literalDict.find( interp );
	if ( ldel != 0 )
		error( loc ) << "literal already defined in this namespace" << endp;

	LexJoin *join = literalJoin( loc, data );

	/* The token definition. */
	TokenDef *tokenDef = TokenDef::cons( name, data, true, false, join, 
			0, loc, 0, nspace, regionSet->tokenIgnore, 0, 0, 0 );

	regionSet->tokenDefList.append( tokenDef );
	nspace->tokenDefList.append( tokenDef );

	/* The instance for the token/ignore region. */
	TokenInstance *tokenInstance = TokenInstance::cons( tokenDef, join, 
			loc, pd->nextTokenId++, nspace, regionSet->tokenIgnore, 0 );

	regionSet->tokenIgnore->tokenInstanceList.append( tokenInstance );

	ldel = nspace->literalDict.insert( interp, tokenInstance );
	nspace->tokenInstanceList.append( tokenInstance );

	/* Make the duplicate for the token-only region. */
	tokenDef->noPreIgnore = noPreIgnore;
	tokenDef->noPostIgnore = noPostIgnore;

	/* The instance for the token-only region. */
	TokenInstance *tokenInstanceTok = TokenInstance::cons( tokenDef,
			join, loc, pd->nextTokenId++, nspace,
			regionSet->tokenOnly, 0 );

	tokenInstanceTok->dupOf = tokenInstance;

	regionSet->tokenOnly->tokenInstanceList.append( tokenInstanceTok );
	nspace->tokenInstanceList.append( tokenInstanceTok );

	if ( !insideRegion )
		popRegionSet();
}

void ColmParser::addArgvList()
{
	TypeRef *typeRef = TypeRef::cons( internal, pd->uniqueTypeStr );
	pd->argvTypeRef = TypeRef::cons( internal, TypeRef::List, 0, typeRef, 0 );
}

ObjectDef *ColmParser::blockOpen()
{
	/* Init the object representing the local frame. */
	ObjectDef *frame = ObjectDef::cons( ObjectDef::FrameType, 
			"local", pd->nextObjectId++ );

	pd->curLocalFrame = frame;

	/* Add captures to the local frame. We Depend on these becoming the
	 * first local variables so we can compute their location. */

	/* Make local variables corresponding to the local capture vector. */
	for ( ReCaptureVect::Iter c = reCaptureVect; c.lte(); c++ )
	{
		ObjectField *objField = ObjectField::cons( c->objField->loc,
				c->objField->typeRef, c->objField->name );

		/* Insert it into the field map. */
		pd->curLocalFrame->insertField( objField->name, objField );
	}

	return frame;
}

void ColmParser::blockClose()
{
	pd->curLocalFrame = pd->rootLocalFrame;
}

void ColmParser::functionDef( StmtList *stmtList, ObjectDef *localFrame,
	ParameterList *paramList, TypeRef *typeRef, const String &name )
{
	CodeBlock *codeBlock = CodeBlock::cons( stmtList, localFrame );
	Function *newFunction = Function::cons( typeRef, name, 
			paramList, codeBlock, pd->nextFuncId++, false );
	pd->functionList.append( newFunction );
	newFunction->inContext = contextStack.top();
}

void ColmParser::iterDef( StmtList *stmtList, ObjectDef *localFrame,
	ParameterList *paramList, const String &name )
{
	CodeBlock *codeBlock = CodeBlock::cons( stmtList, localFrame );
	Function *newFunction = Function::cons( 0, name, 
			paramList, codeBlock, pd->nextFuncId++, true );
	pd->functionList.append( newFunction );
}

LangStmt *ColmParser::globalDef( ObjectField *objField, LangExpr *expr, 
		LangStmt::Type assignType )
{
	LangStmt *stmt = 0;

	ObjectDef *object;
	if ( contextStack.length() == 0 )
		object = pd->globalObjectDef;
	else {
		Context *context = contextStack.top();
		objField->context = context;
		object = context->contextObjDef;
	}

	if ( object->checkRedecl( objField->name ) != 0 )
		error(objField->loc) << "object field renamed" << endp;

	object->insertField( objField->name, objField );

	if ( expr != 0 ) {
		LangVarRef *varRef = LangVarRef::cons( objField->loc, objField->name );

		stmt = LangStmt::cons( objField->loc, 
				assignType, varRef, expr );
	}

	return stmt;
}

void ColmParser::cflDef( NtDef *ntDef, ObjectDef *objectDef, LelDefList *defList )
{
	Namespace *nspace = namespaceStack.top();

	ntDef->objectDef = objectDef;
	ntDef->defList = defList;

	nspace->ntDefList.append( ntDef );

	/* Declare the captures in the object. */
	for ( LelDefList::Iter prod = *defList; prod.lte(); prod++ ) {
		for ( ProdElList::Iter pel = *prod->prodElList; pel.lte(); pel++ ) {
			/* If there is a capture, create the field. */
			if ( pel->captureField != 0 ) {
				/* Might already exist. */
				ObjectField *newOf = objectDef->checkRedecl( pel->captureField->name );
				if ( newOf != 0 ) {
					/* FIXME: check the types are the same. */
				}
				else {
					newOf = pel->captureField;
					newOf->typeRef = pel->typeRef;
					objectDef->insertField( newOf->name, newOf );
				}

				newOf->isRhsGet = true;
				newOf->rhsVal.append( RhsVal( pel ) );
			}
		}
	}
}

ReOrBlock *ColmParser::lexRegularExprData( ReOrBlock *reOrBlock, ReOrItem *reOrItem )
{
	ReOrBlock *ret;

	/* An optimization to lessen the tree size. If an or char is directly under
	 * the left side on the right and the right side is another or char then
	 * paste them together and return the left side. Otherwise just put the two
	 * under a new or data node. */
	if ( reOrItem->type == ReOrItem::Data &&
			reOrBlock->type == ReOrBlock::RecurseItem &&
			reOrBlock->item->type == ReOrItem::Data )
	{
		/* Append the right side to right side of the left and toss the
		 * right side. */
		reOrBlock->item->data += reOrItem->data;
		delete reOrItem;
		ret = reOrBlock;
	}
	else {
		/* Can't optimize, put the left and right under a new node. */
		ret = ReOrBlock::cons( reOrBlock, reOrItem );
	}
	return ret;
}

LexFactor *ColmParser::lexRlFactorName( const String &data, const InputLoc &loc )
{
	LexFactor *factor = 0;
	/* Find the named graph. */
	Namespace *nspace = namespaceStack.top();

	while ( nspace != 0 ) {
		GraphDictEl *gdNode = nspace->rlMap.find( data );
		if ( gdNode != 0 ) {
			if ( gdNode->isInstance ) {
				/* Recover by retuning null as the factor node. */
				error(loc) << "references to graph instantiations not allowed "
						"in expressions" << endl;
				factor = 0;
			}
			else {
				/* Create a factor node that is a lookup of an expression. */
				factor = LexFactor::cons( loc, gdNode->value );
			}
			break;
		}

		nspace = nspace->parentNamespace;
	}

	if ( nspace == 0 ) {
		/* Recover by returning null as the factor node. */
		error(loc) << "graph lookup of \"" << data << "\" failed" << endl;
		factor = 0;
	}

	return factor;
}

int ColmParser::lexFactorRepNum( const InputLoc &loc, const String &data )
{
	/* Convert the priority number to a long. Check for overflow. */
	errno = 0;
	int rep = strtol( data, 0, 10 );
	if ( errno == ERANGE && rep == LONG_MAX ) {
		/* Repetition too large. Recover by returing repetition 1. */
		error(loc) << "repetition number " << data << " overflows" << endl;
		rep = 1;
	}
	return rep;
}

LexFactorAug *ColmParser::lexFactorLabel( const InputLoc &loc, const String &data, LexFactorAug *factorAug )
{
	/* Create the object field. */
	TypeRef *typeRef = TypeRef::cons( loc, pd->uniqueTypeStr );
	ObjectField *objField = ObjectField::cons( loc, typeRef, data );

	/* Create the enter and leaving actions that will mark the substring. */
	Action *enter = Action::cons( MarkMark, pd->nextMatchEndNum++ );
	Action *leave = Action::cons( MarkMark, pd->nextMatchEndNum++ );
	pd->actionList.append( enter );
	pd->actionList.append( leave );
	
	/* Add entering and leaving actions. */
	factorAug->actions.append( ParserAction( loc, at_start, 0, enter ) );
	factorAug->actions.append( ParserAction( loc, at_leave, 0, leave ) );

	reCaptureVect.append( ReCapture( enter, leave, objField ) );
	factorAug->reCaptureVect.append( ReCapture( enter, leave, objField ) );

	return factorAug;
}

LexJoin *ColmParser::lexOptJoin( LexJoin *join, LexJoin *context )
{
	if ( context != 0 ) {
		/* Create the enter and leaving actions that will mark the substring. */
		Action *mark = Action::cons( MarkMark, pd->nextMatchEndNum++ );
		pd->actionList.append( mark );

		join->context = context;
		join->mark = mark;
	}

	return join;
}

LangExpr *ColmParser::send( const InputLoc &loc, LangVarRef *varRef, ConsItemList *list )
{
	Namespace *nspace = namespaceStack.top();
	ParserText *parserText = ParserText::cons( loc, nspace, list );
	pd->parserTextList.append( parserText );

	return LangExpr::cons( LangTerm::cons( InputLoc(),
			LangTerm::SendType, varRef, parserText ) );
}

LangExpr *ColmParser::parseCmd( const InputLoc &loc, bool stop, ObjectField *objField,
		TypeRef *typeRef, FieldInitVect *fieldInitVect, ConsItemList *list )
{
	LangExpr *expr = 0;

	Namespace *nspace = namespaceStack.top();

	/* We are constructing a parser, sending it items, then returning it.
	 * Thisis the constructor for the parser. */
	ConsItemList *emptyConsItemList = new ConsItemList;

	Constructor *constructor = Constructor::cons( loc, nspace,
			emptyConsItemList, pd->nextPatConsId++ );
	pd->replList.append( constructor );
	
	/* The parser may be referenced. */
	LangVarRef *varRef = 0;
	if ( objField != 0 )
		varRef = LangVarRef::cons( objField->loc, objField->name );

	/* The typeref for the parser. */
	TypeRef *parserTypeRef = TypeRef::cons( loc,
			TypeRef::Parser, 0, typeRef, 0 );

	ParserText *parserText = ParserText::cons( loc, nspace, list );
	pd->parserTextList.append( parserText );

	expr = LangExpr::cons( LangTerm::cons( loc, 
			stop ? LangTerm::ParseStopType : LangTerm::ParseType,
			varRef, objField, parserTypeRef, fieldInitVect, constructor, parserText ) );

	/* Check for redeclaration. */
	if ( objField != 0 ) {
		if ( pd->curLocalFrame->checkRedecl( objField->name ) != 0 ) {
			error( objField->loc ) << "variable " << objField->name <<
					" redeclared" << endp;
		}

		/* Insert it into the field map. */
		objField->typeRef = parserTypeRef;
		pd->curLocalFrame->insertField( objField->name, objField );
	}

	return expr;
}

PatternItemList *ColmParser::patternEl( LangVarRef *varRef, PatternItemList *list )
{
	/* Store the variable reference in the pattern itemm. */
	list->head->varRef = varRef;

	if ( varRef != 0 ) {
		if ( pd->curLocalFrame->checkRedecl( varRef->name ) != 0 ) {
			error( varRef->loc ) << "variable " << varRef->name << 
					" redeclared" << endp;
		}

		TypeRef *typeRef = list->head->factor->typeRef;
		ObjectField *objField = ObjectField::cons( InputLoc(), typeRef, varRef->name );

		/* Insert it into the field map. */
		pd->curLocalFrame->insertField( varRef->name, objField );
	}

	return list;
}

PatternItemList *ColmParser::patternElNamed( const InputLoc &loc,
		NamespaceQual *nspaceQual, const String &data, RepeatType repeatType )
{
	TypeRef *typeRef = TypeRef::cons( loc, nspaceQual, data, repeatType );
	ProdEl *prodEl = new ProdEl( ProdEl::ReferenceType, loc, 0, false, typeRef, 0 );
	PatternItem *patternItem = PatternItem::cons( loc, prodEl, PatternItem::FactorType );
	return PatternItemList::cons( patternItem );
}

PatternItemList *ColmParser::patternElType( const InputLoc &loc,
		NamespaceQual *nspaceQual, const String &data, RepeatType repeatType )
{
	PdaLiteral *literal = new PdaLiteral( loc, data );
	TypeRef *typeRef = TypeRef::cons( loc, nspaceQual, literal, repeatType );

	ProdEl *prodEl = new ProdEl( ProdEl::ReferenceType, loc, 0, false, typeRef, 0 );
	PatternItem *patternItem = PatternItem::cons( loc, prodEl, PatternItem::FactorType );
	return PatternItemList::cons( patternItem );
}

PatternItemList *ColmParser::patListConcat( PatternItemList *list1,
		PatternItemList *list2 )
{
	list1->append( *list2 );
	delete list2;
	return list1;
}

ConsItemList *ColmParser::consListConcat( ConsItemList *list1,
		ConsItemList *list2 )
{
	list1->append( *list2 );
	delete list2;
	return list1;
}

LangStmt *ColmParser::forScope( const InputLoc &loc, const String &data,
		TypeRef *typeRef, LangTerm *langTerm, StmtList *stmtList )
{
	/* Check for redeclaration. */
	if ( pd->curLocalFrame->checkRedecl( data ) != 0 )
		error( loc ) << "variable " << data << " redeclared" << endp;

	/* Note that we pass in a null type reference. This type is dependent
	 * on the result of the iter_call lookup since it must contain a reference
	 * to the iterator that is called. This lookup is done at compile time. */
	ObjectField *iterField = ObjectField::cons( loc, (TypeRef*)0, data );
	pd->curLocalFrame->insertField( data, iterField );

	LangStmt *stmt = LangStmt::cons( loc, LangStmt::ForIterType, 
			iterField, typeRef, langTerm, stmtList );

	return stmt;
}

void ColmParser::preEof( const InputLoc &loc, StmtList *stmtList, ObjectDef *localFrame )
{
	bool insideRegion = regionStack.length() > 1;
	if ( !insideRegion )
		error(loc) << "preeof must be used inside an existing region" << endl;

	CodeBlock *codeBlock = CodeBlock::cons( stmtList, localFrame );
	codeBlock->context = contextStack.length() == 0 ? 0 : contextStack.top();

	RegionSet *regionSet = regionStack.top();
	regionSet->tokenIgnore->preEofBlock = codeBlock;
}

ProdEl *ColmParser::prodElName( const InputLoc &loc, const String &data,
		NamespaceQual *nspaceQual, ObjectField *objField,
		RepeatType repeatType, bool commit )
{
	TypeRef *typeRef = TypeRef::cons( loc, nspaceQual, data, repeatType );
	ProdEl *prodEl = new ProdEl( ProdEl::ReferenceType, loc, objField, commit, typeRef, 0 );
	return prodEl;
}

ProdEl *ColmParser::prodElLiteral( const InputLoc &loc, const String &data,
		NamespaceQual *nspaceQual, ObjectField *objField, RepeatType repeatType,
		bool commit )
{
	/* Create a new prodEl node going to a concat literal. */
	PdaLiteral *literal = new PdaLiteral( loc, data );
	TypeRef *typeRef = TypeRef::cons( loc, nspaceQual, literal, repeatType );
	ProdEl *prodEl = new ProdEl( ProdEl::LiteralType, loc, objField, commit, typeRef, 0 );
	return prodEl;
}

ConsItemList *ColmParser::consElLiteral( const InputLoc &loc,
		const String &data, NamespaceQual *nspaceQual )
{
	PdaLiteral *literal = new PdaLiteral( loc, data );
	TypeRef *typeRef = TypeRef::cons( loc, nspaceQual, literal );
	ProdEl *prodEl = new ProdEl( ProdEl::LiteralType, loc, 0, false, typeRef, 0 );
	ConsItem *consItem = ConsItem::cons( loc, ConsItem::FactorType, prodEl );
	ConsItemList *list = ConsItemList::cons( consItem );
	return list;
}

Production *ColmParser::production( const InputLoc &loc, ProdElList *prodElList,
		bool commit, CodeBlock *codeBlock, LangEl *predOf )
{
	Production *prod = Production::cons( loc, 0, prodElList,
			commit, codeBlock, pd->prodList.length(), 0 );
	prod->predOf = predOf;

	/* Link the production elements back to the production. */
	for ( ProdEl *prodEl = prodElList->head; prodEl != 0; prodEl = prodEl->next )
		prodEl->production = prod;

	pd->prodList.append( prod );

	return prod;
}

void ColmParser::objVarDef( ObjectField *objField )
{
	if ( curObjectDef->checkRedecl( objField->name ) != 0 )
		error() << "object field renamed" << endp;

	curObjectDef->insertField( objField->name, objField );
}

LelDefList *ColmParser::prodAppend( LelDefList *defList, Production *definition )
{
	definition->prodNum = defList->length();
	defList->append( definition );
	return defList;
}

LangExpr *ColmParser::construct( const InputLoc &loc, ObjectField *objField,
		ConsItemList *list, TypeRef *typeRef, FieldInitVect *fieldInitVect )
{
	Namespace *nspace = namespaceStack.top();
	Constructor *constructor = Constructor::cons( loc, nspace,
			list, pd->nextPatConsId++ );
	pd->replList.append( constructor );
	
	LangVarRef *varRef = 0;
	if ( objField != 0 )
		varRef = LangVarRef::cons( objField->loc, objField->name );

	LangExpr *expr = LangExpr::cons( LangTerm::cons( loc, LangTerm::ConstructType,
			varRef, objField, typeRef, fieldInitVect, constructor ) );

	/* Check for redeclaration. */
	if ( objField != 0 ) {
		if ( pd->curLocalFrame->checkRedecl( objField->name ) != 0 ) {
			error( objField->loc ) << "variable " << objField->name <<
					" redeclared" << endp;
		}

		/* Insert it into the field map. */
		objField->typeRef = typeRef;
		pd->curLocalFrame->insertField( objField->name, objField );
	}

	return expr;
}

LangExpr *ColmParser::match( const InputLoc &loc, LangVarRef *varRef,
		PatternItemList *list )
{
	Namespace *nspace = namespaceStack.top();

	Pattern *pattern = Pattern::cons( loc, nspace,
			list, pd->nextPatConsId++ );
	pd->patternList.append( pattern );

	LangExpr *expr = LangExpr::cons( LangTerm::cons( 
			InputLoc(), LangTerm::MatchType, varRef, pattern ) );

	return expr;
}

LangStmt *ColmParser::varDef( ObjectField *objField,
		LangExpr *expr, LangStmt::Type assignType )
{
	LangStmt *stmt = 0;

	/* Check for redeclaration. */
	if ( pd->curLocalFrame->checkRedecl( objField->name ) != 0 ) {
		error( objField->loc ) << "variable " << objField->name <<
				" redeclared" << endp;
	}

	/* Insert it into the field map. */
	pd->curLocalFrame->insertField( objField->name, objField );

	//cout << "var def " << $1->objField->name << endl;

	if ( expr != 0 ) {
		LangVarRef *varRef = LangVarRef::cons( objField->loc, 
				objField->name );

		stmt = LangStmt::cons( objField->loc, assignType, varRef, expr );
	}

	return stmt;
}

LangStmt *ColmParser::exportStmt( ObjectField *objField, LangStmt::Type assignType, LangExpr *expr )
{
	LangStmt *stmt = 0;

	if ( contextStack.length() != 0 )
		error(objField->loc) << "cannot export parser context variables" << endp;

	ObjectDef *object = pd->globalObjectDef;

	if ( object->checkRedecl( objField->name ) != 0 )
		error(objField->loc) << "object field renamed" << endp;

	object->insertField( objField->name, objField );
	objField->isExport = true;

	if ( expr != 0 ) {
		LangVarRef *varRef = LangVarRef::cons( objField->loc, 
				objField->name );

		stmt = LangStmt::cons( objField->loc, assignType, varRef, expr );
	}

	return stmt;
}

LangExpr *ColmParser::require( const InputLoc &loc,
		LangVarRef *varRef, PatternItemList *list )
{
	Namespace *nspace = namespaceStack.top();

	Pattern *pattern = Pattern::cons( loc, nspace,
			list, pd->nextPatConsId++ );
	pd->patternList.append( pattern );

	LangExpr *expr = LangExpr::cons( LangTerm::cons(
			InputLoc(), LangTerm::MatchType, varRef, pattern ) );
	return expr;
}

void ColmParser::contextVarDef( const InputLoc &loc, ObjectField *objField )
{
	ObjectDef *object;
	if ( contextStack.length() == 0 )
		error(loc) << "internal error: no context stack items found" << endp;

	Context *context = contextStack.top();
	objField->context = context;
	object = context->contextObjDef;

	if ( object->checkRedecl( objField->name ) != 0 )
		error(objField->loc) << "object field renamed" << endp;

	object->insertField( objField->name, objField );
}

void ColmParser::contextHead( const InputLoc &loc, const String &data )
{
	/* Make the new namespace. */
	Namespace *nspace = createNamespace( loc, data );

	Context *context = new Context( loc, 0 );
	contextStack.push( context );

	ContextDef *contextDef = new ContextDef( data, context, nspace );
	nspace->contextDefList.append( contextDef );

	context->contextObjDef = ObjectDef::cons( ObjectDef::UserType,
			data, pd->nextObjectId++ ); 
}

void ColmParser::tokenInstanceName( const String &name )
{
	pd->insideRegion = regionStack.length() > 1;
	curDefineId = name;

	if ( !pd->insideRegion )
		pushRegionSet( internal );
}

StmtList *ColmParser::appendStatement( StmtList *stmtList, LangStmt *stmt )
{
	if ( stmt != 0 )
		stmtList->append( stmt );
	return stmtList;
}

ParameterList *ColmParser::appendParam( ParameterList *paramList, ObjectField *objField )
{
	paramList->append( objField );
	return paramList;
}

ObjectField *ColmParser::addParam( const InputLoc &loc, TypeRef *typeRef,
		const String &name )
{
	ObjectField *objField = ObjectField::cons( loc, typeRef, name );
	objField->isParam = true;
	return objField;
}

void ColmParser::predTokenName( const InputLoc &loc, NamespaceQual *qual,
		const String &data )
{
	TypeRef *typeRef = TypeRef::cons( loc, qual, data );
	PredDecl *predDecl = new PredDecl( typeRef, predType, pd->predValue );
	pd->predDeclList.append( predDecl );
}

void ColmParser::predTokenLit( const InputLoc &loc, const String &data,
		NamespaceQual *nspaceQual )
{
	PdaLiteral *literal = new PdaLiteral( loc, data );
	TypeRef *typeRef = TypeRef::cons( loc, nspaceQual, literal );
	PredDecl *predDecl = new PredDecl( typeRef, predType, pd->predValue );
	pd->predDeclList.append( predDecl );
}

void ColmParser::alias( const InputLoc &loc, const String &data, TypeRef *typeRef )
{
	Namespace *nspace = namespaceStack.top();
	TypeAlias *typeAlias = new TypeAlias( loc, nspace, data, typeRef );
	nspace->typeAliasList.append( typeAlias );
}

%%{

parser ColmParser;

include "lmparse.kh";

start: root_item_list
	final {
		pd->rootCodeBlock = CodeBlock::cons( $1->stmtList, 0 );
	};

nonterm root_item_list uses lang_stmt_list;

root_item_list: root_item_list root_item
	final {
		$$->stmtList = appendStatement( $1->stmtList, $2->stmt );
	};

root_item_list: 
	final {
		$$->stmtList = new StmtList;
	};

nonterm root_item uses statement;

root_item: literal_def commit final { $$->stmt = 0; };
root_item: rl_def commit final { $$->stmt = 0; };
root_item: token_def commit final { $$->stmt = 0; };
root_item: cfl_def commit final { $$->stmt = 0; };
root_item: region_def commit final { $$->stmt = 0; };
root_item: context_def commit final { $$->stmt = 0; };
root_item: namespace_def commit final { $$->stmt = 0; };
root_item: function_def commit final { $$->stmt = 0; };
root_item: iter_def commit final { $$->stmt = 0; };
root_item: global_def commit final { $$->stmt = $1->stmt; };
root_item: export_def commit final { $$->stmt = 0; };
root_item: statement commit final { $$->stmt = $1->stmt; };
root_item: pre_eof commit final { $$->stmt = 0; };
root_item: precedence commit final { $$->stmt = 0; };
root_item: typedef commit final { $$->stmt = 0; };

nonterm block_open
{
	ObjectDef *localFrame;
};

block_open: '{' 
	final {
		$$->localFrame = blockOpen();
	};

block_close: '}' 
	final {
		blockClose();
	};


iter_def: 
	KW_Iter TK_Word '(' opt_param_list ')' block_open lang_stmt_list block_close
	final {
		iterDef( $7->stmtList, $6->localFrame, $4->paramList, $2->data );
	};

function_def: 
	type_ref TK_Word '(' opt_param_list ')' block_open lang_stmt_list block_close
	final {
		functionDef( $7->stmtList, $6->localFrame, $4->paramList, $1->typeRef, $2->data );
	};

nonterm opt_param_list uses param_list;

opt_param_list: param_list
	final {
		$$->paramList = $1->paramList;
	};
		
opt_param_list: 
	final {
		$$->paramList = new ParameterList;
	};

nonterm param_list
{
	ParameterList *paramList;
};

param_list: param_list param_var_def
	final {
		$$->paramList = appendParam( $1->paramList, $2->objField );
	};

param_list: param_var_def
	final {
		$$->paramList = appendParam( new ParameterList, $1->objField );
	};

nonterm param_var_def uses var_def;

param_var_def: TK_Word ':' type_ref
	final {
		$$->objField = addParam( $1->loc, $3->typeRef, $1->data );
	};
param_var_def: TK_Word ':' reference_type_ref
	final {
		$$->objField = addParam( $1->loc, $3->typeRef, $1->data );
	};

nonterm reference_type_ref uses type_ref;

reference_type_ref: KW_Ref type_ref
	final {
		$$->typeRef = TypeRef::cons( $1->loc, TypeRef::Ref, $2->typeRef );
	};

nonterm global_def uses statement;

global_def: KW_Global var_def opt_def_init
	final {
		$$->stmt = globalDef( $2->objField, $3->expr, $3->assignType );
	};

nonterm export_def uses statement;

export_def: KW_Export var_def opt_def_init
	final {
		$$->stmt = exportStmt( $2->objField, $3->assignType, $3->expr );
	};

precedence: pred_type pred_token_list final { pd->predValue++; };

pred_type: KW_Left final { predType = PredLeft; };
pred_type: KW_Right final { predType = PredRight; };
pred_type: KW_Nonassoc final { predType = PredNonassoc; };

pred_token_list: pred_token_list ',' pred_token;
pred_token_list: pred_token;

nonterm pred_token
{
	ProdEl *factor;
	TypeRef *typeRef;
};

pred_token: 
	region_qual TK_Word 
	final {
		predTokenName( $2->loc, $1->nspaceQual, $2->data );
	};

pred_token: 
	region_qual TK_Literal 
	final {
		predTokenLit( $2->loc, $2->data, $1->nspaceQual );
	};

typedef:
	KW_Alias TK_Word type_ref
	final {
		alias( $1->loc, $2->data, $3->typeRef );
	};

cfl_def:
	cfl_def_head obj_var_list opt_reduce_first cfl_prod_list
	final {
		NtDef *ntDef = NtDef::cons( $1->name, namespaceStack.top(),
				contextStack.top(), $3->reduceFirst );

		cflDef( ntDef, curObjectDef, $4->defList );
	};

nonterm class cfl_def_head
{
	String name;
};

cfl_def_head: KW_Def TK_Word
	final {
		curDefineId = $2->data;
		$$->name = $2->data;
	};

nonterm cfl_prod_list
{
	LelDefList *defList;
};

cfl_prod_list: cfl_prod_list '|' define_prod
	final {
		$$->defList = prodAppend( $1->defList, $3->definition );
	};
cfl_prod_list: define_prod
	final {
		$$->defList = prodAppend( new LelDefList, $1->definition );
	};

nonterm opt_reduce_first
{
	bool reduceFirst;
};

opt_reduce_first:
	KW_ReduceFirst
	final {
		$$->reduceFirst = true;
	};
opt_reduce_first: 
	final {
		$$->reduceFirst = false;
	};

nonterm opt_prec
{
	LangEl *predOf;
};

opt_prec:
	final {
		$$->predOf = 0;
	};

opt_prec: 
	KW_Prec pred_token
	final {
		$$->predOf = $2->factor->langEl;
	};

nonterm define_prod
{
	Production *definition;
};

define_prod: '[' prod_el_list ']' opt_commit opt_reduce_code opt_prec
	final {
		$$->definition = production( $1->loc, $2->list, $4->commit,
				$5->codeBlock, $6->predOf );
	};

obj_var_list: obj_var_list var_def
	final {
		objVarDef( $2->objField );
	};

obj_var_list:
	final {
		curObjectDef = ObjectDef::cons( ObjectDef::UserType,
				curDefineId, pd->nextObjectId++ ); 
	};


nonterm type_ref
{
	TypeRef *typeRef;
};

type_ref: basic_type_ref
	final {
		$$->typeRef = $1->typeRef;
	};

type_ref: KW_Map '<' type_ref type_ref '>'
	final {
		$$->typeRef = TypeRef::cons( $1->loc, TypeRef::Map, 
				0, $3->typeRef, $4->typeRef );
	};

type_ref: KW_List '<' type_ref '>'
	final {
		$$->typeRef = TypeRef::cons( $1->loc, TypeRef::List,
				0, $3->typeRef, 0 );
	};
type_ref: KW_Vector '<' type_ref '>'
	final {
		$$->typeRef = TypeRef::cons( $1->loc, TypeRef::Vector,
				0, $3->typeRef, 0 );
	};
type_ref: KW_Parser '<' type_ref '>'
	final {
		$$->typeRef = TypeRef::cons( $1->loc, TypeRef::Parser,
				0, $3->typeRef, 0 );
	};

nonterm basic_type_ref uses type_ref;

basic_type_ref: region_qual TK_Word opt_repeat
	final {
		$$->typeRef = TypeRef::cons( $2->loc, $1->nspaceQual, $2->data, $3->repeatType );
	};

basic_type_ref: KW_Ptr region_qual TK_Word opt_repeat
	final {
		TypeRef *inner = TypeRef::cons( $1->loc, $2->nspaceQual, $3->data, $4->repeatType );
		$$->typeRef = TypeRef::cons( $1->loc, TypeRef::Ptr, inner );
	};


nonterm var_def
{
	InputLoc loc;
	ObjectField *objField;
};

var_def: TK_Word ':' type_ref
	final {
		/* Return an object field object. The user of this nonterminal must
		 * load it into the approrpriate map and do error checking. */
		$$->objField = ObjectField::cons( $1->loc, $3->typeRef, $1->data );
	};

region_def: 
	region_head root_item_list KW_End
	final {
		popRegionSet();
	};

region_head: 
	KW_Lex
	final {
		pushRegionSet( $1->loc );
	};

namespace_def: 
	namespace_head root_item_list KW_End
	final {
		namespaceStack.pop();
	};


namespace_head: 
	KW_Namespace TK_Word 
	final {
		/* Make the new namespace. */
		createNamespace( $1->loc, $2->data );
	};

context_var_def: 
	var_def 
	final {
		contextVarDef( $1->loc, $1->objField );
	};


context_item: context_var_def commit;
context_item: literal_def commit;
context_item: rl_def commit;
context_item: token_def commit;
context_item: cfl_def commit;
context_item: region_def commit;
context_item: context_def commit;
context_item: function_def commit;
context_item: iter_def commit;
context_item: export_def commit;
context_item: pre_eof commit;
context_item: precedence commit;

context_item_list:
	context_item_list context_item;
context_item_list:
	;

context_def: 
	context_head context_item_list KW_End
	final {
		contextStack.pop();
		namespaceStack.pop();
	};

context_head:
	KW_Context TK_Word
	final {
		contextHead( $1->loc, $2->data );
	};

#
# Pattern
#

nonterm pattern
{
	PatternItemList *list;
	InputLoc loc;
};

pattern: 	
	pattern_list
	final {
		$$->list = $1->list;
	};

nonterm pattern_list uses pattern;

pattern_list: pattern_list pattern_top_el
	final {
		$$->list = patListConcat( $1->list, $2->list );
	};
pattern_list: pattern_top_el
	final {
		$$->list = $1->list;
	};

nonterm pattern_top_el uses pattern;

pattern_top_el: '"' litpat_el_list '"'
	final {
		$$->list = $2->list;
	};
pattern_top_el: '[' pattern_el_list ']'
	final {
		$$->list = $2->list;
	};

nonterm litpat_el_list uses pattern;

litpat_el_list: litpat_el_list litpat_el
	final {
		$$->list = patListConcat( $1->list, $2->list );
	};
litpat_el_list: 
	final {
		$$->list = new PatternItemList;
	};

nonterm litpat_el uses pattern;

litpat_el: TK_LitPat
	final {
		PatternItem *patternItem = PatternItem::cons( $1->loc, $1->data,
				PatternItem::InputText );
		$$->list = PatternItemList::cons( patternItem );
	};

litpat_el: '[' pattern_el_list ']'
	final {
		$$->list = $2->list;
	};

nonterm pattern_el_list uses pattern;

pattern_el_list: 
	pattern_el_list pattern_el
	final {
		$$->list = patListConcat( $1->list, $2->list );
	};
pattern_el_list: 
	final {
		$$->list = new PatternItemList;
	};

nonterm pattern_el uses pattern;

pattern_el: 
	opt_label pattern_el_type_or_lit
	final {
		$$->list = patternEl( $1->varRef, $2->list );
	};

nonterm pattern_el uses pattern;

pattern_el: '"' litpat_el_list '"'
	final {
		$$->list = $2->list;
	};
pattern_el: '?' TK_Word
	final {
		/* FIXME: Implement */
		assert(false);
	};

nonterm pattern_el_type_or_lit uses pattern;

pattern_el_type_or_lit: 
	region_qual TK_Word opt_repeat
	final {
		$$->list = patternElNamed( $2->loc, $1->nspaceQual, $2->data, $3->repeatType );
	};

pattern_el_type_or_lit: 
	region_qual TK_Literal opt_repeat
	final {
		$$->list = patternElType( $2->loc, $1->nspaceQual, $2->data, $3->repeatType );
	};

nonterm opt_label
{
	/* Variable reference. */
	LangVarRef *varRef;
};

opt_label: TK_Word ':'
	final {
		$$->varRef = LangVarRef::cons( $1->loc, $1->data );
	};
opt_label: 
	final {
		$$->varRef = 0;
	};

#
# Constructor List (constructor)
#

nonterm constructor
{
	ConsItemList *list;
};

constructor: cons_list
	final {
		$$->list = $1->list;
	};

nonterm cons_list uses constructor;

cons_list: cons_top_el cons_list
	final {
		$$->list = consListConcat( $1->list, $2->list );
	};
cons_list: cons_top_el
	final {
		$$->list = $1->list;
	};

nonterm cons_top_el uses constructor;

cons_top_el: '"' lit_cons_el_list '"'
	final {
		$$->list = $2->list;
	};
cons_top_el: '[' cons_el_list ']'
	final {
		$$->list = $2->list;
	};

nonterm lit_cons_el_list uses constructor;

lit_cons_el_list: lit_cons_el_list lit_cons_el
	final {
		$$->list = consListConcat( $1->list, $2->list );
	};
lit_cons_el_list: 
	final {
		$$->list = new ConsItemList;
	};

nonterm lit_cons_el uses constructor;

lit_cons_el: TK_LitPat
	final {
		ConsItem *consItem = ConsItem::cons( $1->loc, ConsItem::InputText, $1->data );
		$$->list = ConsItemList::cons( consItem );
	};

lit_cons_el: '[' cons_el_list ']'
	final {
		$$->list = $2->list;
	};

nonterm cons_el_list uses constructor;

cons_el_list: cons_el_list cons_el
	final {
		$$->list = consListConcat( $1->list, $2->list );
	};
cons_el_list: 
	final {
		$$->list = new ConsItemList;
	};

nonterm cons_el uses constructor;

cons_el: region_qual TK_Literal
	final {
		$$->list = consElLiteral( $2->loc, $2->data, $1->nspaceQual );
	};

cons_el: '"' lit_cons_el_list '"'
	final {
		$$->list = $2->list;
	};

cons_el: code_expr
	final {
		ConsItem *consItem = ConsItem::cons( $1->expr->loc, ConsItem::ExprType, $1->expr );
		$$->list = ConsItemList::cons( consItem );
	};

#
# Accumulate List
#

nonterm accumulate
{
	ConsItemList *list;
};

accumulate: 
	accum_list
	final {
		$$->list = $1->list;
	};

nonterm accum_list uses accumulate;

accum_list: accum_top_el accum_list
	final {
		$$->list = consListConcat( $1->list, $2->list );
	};

accum_list: accum_top_el
	final {
		$$->list = $1->list;
	};

nonterm accum_top_el uses accumulate;

accum_top_el: '"' lit_accum_el_list '"'
	final {
		$$->list = $2->list;
	};

accum_top_el: '[' accum_el_list ']'
	final {
		$$->list = $2->list;
	};

nonterm lit_accum_el_list uses accumulate;

lit_accum_el_list:
	lit_accum_el_list lit_accum_el
	final {
		$$->list = consListConcat( $1->list, $2->list );
	};

lit_accum_el_list: 
	final {
		$$->list = new ConsItemList;
	};

nonterm lit_accum_el uses accumulate;

lit_accum_el: TK_LitPat
	final {
		ConsItem *consItem = ConsItem::cons( $1->loc, ConsItem::InputText, $1->data );
		$$->list = ConsItemList::cons( consItem );
	};

lit_accum_el: '[' accum_el_list ']'
	final {
		$$->list = $2->list;
	};

nonterm accum_el_list uses accumulate;

accum_el_list: accum_el_list accum_el
	final {
		$$->list = consListConcat( $1->list, $2->list );
	};
		
accum_el_list:
	final {
		$$->list = new ConsItemList;
	};

nonterm accum_el uses accumulate;

accum_el: code_expr
	final {
		ConsItem *consItem = ConsItem::cons( $1->expr->loc, ConsItem::ExprType, $1->expr );
		$$->list = ConsItemList::cons( consItem );
	};

accum_el: '"' lit_accum_el_list '"'
	final {
		$$->list = $2->list;
	};


#
# String List
#

nonterm string
{
	ConsItemList *list;
};

string: string_list
	final {
		$$->list = $1->list;
	};

nonterm string_list uses string;

string_list: string_top_el string_list
	final {
		$$->list = consListConcat( $1->list, $2->list );
	};
string_list: string_top_el
	final {
		$$->list = $1->list;
	};

nonterm string_top_el uses string;

string_top_el: '"' lit_string_el_list '"'
	final {
		$$->list = $2->list;
	};
string_top_el: '[' string_el_list ']'
	final {
		$$->list = $2->list;
	};

nonterm lit_string_el_list uses string;

lit_string_el_list: lit_string_el_list lit_string_el
	final {
		$$->list = consListConcat( $1->list, $2->list );
	};
lit_string_el_list: 
	final {
		$$->list = new ConsItemList;
	};

nonterm lit_string_el uses string;

lit_string_el: TK_LitPat
	final {
		ConsItem *consItem = ConsItem::cons( $1->loc, ConsItem::InputText, $1->data );
		$$->list = ConsItemList::cons( consItem );
	};

lit_string_el: '[' string_el_list ']'
	final {
		$$->list = $2->list;
	};

nonterm string_el_list uses string;

string_el_list: string_el_list string_el
	final {
		$$->list = consListConcat( $1->list, $2->list );
	};
string_el_list: 
	final {
		$$->list = new ConsItemList;
	};

nonterm string_el uses string;

string_el: code_expr
	final {
		ConsItem *consItem = ConsItem::cons( $1->expr->loc, ConsItem::ExprType, $1->expr );
		$$->list = ConsItemList::cons( consItem );
	};

string_el: '"' lit_string_el_list '"'
	final {
		$$->list = $2->list;
	};

#
# Production Lists.
#

nonterm prod_el_list
{
	ProdElList *list;
};

prod_el_list: 
	prod_el_list prod_el 
	final {
		$2->prodEl->pos = $1->list->length();
		$$->list = $1->list;
		$$->list->append( $2->prodEl );
	};

prod_el_list: 
	final {
		$$->list = new ProdElList;
	};

nonterm opt_no_ignore { bool noIgnore; };

opt_no_ignore: KW_Ni final { $$->noIgnore = true; };
opt_no_ignore:       final { $$->noIgnore = false; };

nonterm prod_el
{
	ProdEl *prodEl;
};

prod_el: 
	opt_capture opt_commit region_qual TK_Word opt_repeat
	final {
		$$->prodEl = prodElName( $4->loc, $4->data, $3->nspaceQual,
				$1->objField, $5->repeatType, $2->commit );
	};

prod_el: 
	opt_capture opt_commit region_qual TK_Literal opt_repeat
	final {
		$$->prodEl = prodElLiteral( $4->loc, $4->data, $3->nspaceQual,
				$1->objField, $5->repeatType, $2->commit );
	};

nonterm opt_repeat
{
	bool opt;
	bool repeat;
	RepeatType repeatType;
};

opt_repeat: '*' final { $$->opt = false; $$->repeat = true; $$->repeatType = RepeatRepeat; };
opt_repeat: '+' final { $$->opt = false; $$->repeat = false; $$->repeatType = RepeatList; };
opt_repeat: '?' final { $$->opt = true; $$->repeat = false; $$->repeatType = RepeatOpt; };
opt_repeat:     final { $$->opt = false; $$->repeat = false; $$->repeatType = RepeatNone; };

nonterm region_qual
{
	NamespaceQual *nspaceQual;
};

region_qual: region_qual TK_Word TK_DoubleColon
	final {
		$$->nspaceQual = $1->nspaceQual;
		$$->nspaceQual->qualNames.append( $2->data );
	};

region_qual: 
	final {
		$$->nspaceQual = NamespaceQual::cons( namespaceStack.top() );
	};

literal_def: KW_Literal literal_list;

literal_list: literal_list ',' literal_item;
literal_list: literal_item;

literal_item: opt_no_ignore TK_Literal opt_no_ignore
	final {
		if ( strcmp( $2->data, "''" ) == 0 )
			zeroDef( $2->loc, $2->data, $1->noIgnore, $3->noIgnore );
		else
			literalDef( $2->loc, $2->data, $1->noIgnore, $3->noIgnore );
	};


# These two productions are responsible for setting and unsetting the Regular
# language scanning context.
enter_rl:
	try {
		enterRl = true;
	}
	undo {
		enterRl = false;
	};
leave_rl:
	try {
		enterRl = false;
	}
	undo {
		enterRl = true;
	};

token_def: 
	token_or_ignore token_def_name obj_var_list
	enter_rl opt_no_ignore '/' opt_lex_join leave_rl '/' opt_no_ignore  
	opt_translate
	final {
		tokenInstance( $1->loc, $2->name, $7->join, $11->transBlock, $1->ignore,
				$5->noIgnore, $10->noIgnore );
	};

nonterm token_or_ignore
{
	InputLoc loc;
	bool ignore;
};

token_or_ignore: KW_Token
	final { $$->loc = $1->loc; $$->ignore = false; };
	
token_or_ignore: KW_Ignore
	final { $$->loc = $1->loc; $$->ignore = true; };

nonterm class token_def_name
{
	String name;
};

token_def_name:
	opt_name
	final {
		tokenInstanceName( $1->name );
		$$->name = $1->name;
	};

nonterm class opt_name
{
	String name;
};

opt_name: TK_Word final { $$->name = $1->data; };
opt_name: ;

nonterm opt_translate
{
	CodeBlock *transBlock;
};

opt_translate: 
	block_open lang_stmt_list block_close
	final { 
		$$->transBlock = CodeBlock::cons( $2->stmtList, $1->localFrame );
		$$->transBlock->context = contextStack.top();
	};

opt_translate: 
	final {
		$$->transBlock = 0;
	};

pre_eof: 
	KW_Preeof block_open lang_stmt_list block_close
	final {
		preEof( $1->loc, $3->stmtList, $2->localFrame );
	};

rl_def:
	KW_Rl machine_name enter_rl '/' lex_join leave_rl '/'
	final {
		/* Generic creation of machine for instantiation and assignment. */
		addRegularDef( $2->loc, namespaceStack.top(), $2->data, $5->join );

		if ( reCaptureVect.length() > 0 )
			error($1->loc) << "rl definitions cannot capture vars" << endl;
	};

type class token_data
{
	InputLoc loc;
	String data;
};

nonterm machine_name uses token_data;

machine_name: 
	TK_Word
	final {
		$$->loc = $1->loc;
		$$->data = $1->data;
	};

#
# Reduce statements
#

nonterm opt_reduce_code
{
	CodeBlock *codeBlock;
};

opt_reduce_code: 
	final { $$->codeBlock = 0; };

opt_reduce_code: 
	start_reduce lang_stmt_list block_close
	final { 
		$$->codeBlock = CodeBlock::cons( $2->stmtList, $1->localFrame );
		$$->codeBlock->context = contextStack.top();
	};

nonterm start_reduce uses block_open;

start_reduce: 
	block_open
	final {
		$$->localFrame = $1->localFrame;
	};

nonterm lang_stmt_list
{
	StmtList *stmtList;
};

lang_stmt_list: rec_stmt_list opt_require_stmt
	final {
		$$->stmtList = $1->stmtList;
		if ( $2->stmt != 0 )
			$$->stmtList->append( $2->stmt );
	};

nonterm rec_stmt_list uses lang_stmt_list;

rec_stmt_list: rec_stmt_list statement
	final {
		$$->stmtList = $1->stmtList;

		/* Maybe a statement was generated. */
		if ( $2->stmt != 0 )
			$$->stmtList->append( $2->stmt );
	};

rec_stmt_list:
	final {
		$$->stmtList = new StmtList;
	};

nonterm opt_def_init
{
	LangExpr *expr;
	LangStmt::Type assignType;
};

opt_def_init: '=' code_expr
	final {
		$$->expr = $2->expr;
		$$->assignType = LangStmt::AssignType;
	};
opt_def_init: 
	final {
		$$->expr = 0;
	};

scope_push:
	final {
		pd->curLocalFrame->pushScope();
	};

scope_pop: 
	final {
		pd->curLocalFrame->popScope();
	};

nonterm statement
{
	LangStmt *stmt;
};
nonterm for_scope uses statement;

statement: var_def opt_def_init 
	final {
		$$->stmt = varDef( $1->objField, $2->expr, $2->assignType );
	};
statement: var_ref '=' code_expr
	final {
		$$->stmt = LangStmt::cons( $2->loc, LangStmt::AssignType, $1->varRef, $3->expr );
	};
statement: KW_Print '(' code_expr_list ')'
	final {
		$$->stmt = LangStmt::cons( $1->loc, LangStmt::PrintType, $3->exprVect );
	};
statement: KW_PrintXMLAC '(' code_expr_list ')'
	final {
		$$->stmt = LangStmt::cons( $1->loc, LangStmt::PrintXMLACType, $3->exprVect );
	};
statement: KW_PrintXML '(' code_expr_list ')'
	final {
		$$->stmt = LangStmt::cons( $1->loc, LangStmt::PrintXMLType, $3->exprVect );
	};
statement: KW_PrintStream '(' code_expr_list ')'
	final {
		$$->stmt = LangStmt::cons( $1->loc, LangStmt::PrintStreamType, $3->exprVect );
	};
statement: code_expr
	final {
		$$->stmt = LangStmt::cons( InputLoc(), LangStmt::ExprType, $1->expr );
	};
statement: if_stmt
	final {
		$$->stmt = $1->stmt;
	};
statement: KW_Reject
	final {
		$$->stmt = LangStmt::cons( $1->loc, LangStmt::RejectType );
	};
statement: KW_While scope_push code_expr block_or_single scope_pop
	final {
		$$->stmt = LangStmt::cons( LangStmt::WhileType, $3->expr, $4->stmtList );
	};

for_scope: TK_Word ':' type_ref KW_In iter_call block_or_single
	final {
		$$->stmt = forScope( $1->loc, $1->data, $3->typeRef, $5->langTerm, $6->stmtList );
	};

statement: KW_For scope_push for_scope scope_pop
	final {
		$$->stmt = $3->stmt;
	};

statement: KW_Return code_expr
	final {
		$$->stmt = LangStmt::cons( $1->loc, LangStmt::ReturnType, $2->expr );
	};
statement: KW_Break
	final {
		$$->stmt = LangStmt::cons( LangStmt::BreakType );
	};
statement: KW_Yield var_ref
	final {
		$$->stmt = LangStmt::cons( LangStmt::YieldType, $2->varRef );
	};

nonterm opt_require_stmt uses statement;

opt_require_stmt: 
	scope_push require_pattern lang_stmt_list scope_pop
	final {
		$$->stmt = LangStmt::cons( LangStmt::IfType, $2->expr, $3->stmtList, 0 );
	};
opt_require_stmt:
	final {
		$$->stmt = 0;
	};

nonterm require_pattern uses code_expr;

require_pattern: 
	KW_Require var_ref pattern 
	final {
		$$->expr = require( $1->loc, $2->varRef, $3->list );
	};

nonterm block_or_single uses lang_stmt_list;

block_or_single: '{' lang_stmt_list '}'
	final {
		$$->stmtList = $2->stmtList;
	};
block_or_single: statement
	final {
		$$->stmtList = new StmtList;
		$$->stmtList->append( $1->stmt );
	};

nonterm iter_call
{
	LangTerm *langTerm;
};

iter_call: var_ref '(' opt_code_expr_list ')'
	final {
		$$->langTerm = LangTerm::cons( InputLoc(), $1->varRef, $3->exprVect );
	};
iter_call: TK_Word
	final {
		$$->langTerm = LangTerm::cons( InputLoc(), LangTerm::VarRefType,
			LangVarRef::cons( $1->loc, $1->data ) );
	};

#
# If Statements
#

nonterm if_stmt uses statement;

if_stmt: KW_If scope_push code_expr block_or_single scope_pop elsif_list
	final {
		$$->stmt = LangStmt::cons( LangStmt::IfType, $3->expr, $4->stmtList, $6->stmt );
	};

nonterm elsif_list
{
	LangStmt *stmt;
};

elsif_list: 
	elsif_clause elsif_list
	final {
		/* Put any of the followng elseif part, an else, or null into the elsePart. */
		$$->stmt = $1->stmt;
		$$->stmt->elsePart = $2->stmt;
	};
elsif_list:
	optional_else
	final {
		$$->stmt = $1->stmt;
	};

nonterm elsif_clause
{
	LangStmt *stmt;
};

elsif_clause: 
	KW_Elsif scope_push code_expr block_or_single scope_pop
	final {
		$$->stmt = LangStmt::cons( LangStmt::IfType, $3->expr, $4->stmtList, 0 );
	};

nonterm optional_else
{
	LangStmt *stmt;
};

optional_else: 
	KW_Else scope_push block_or_single scope_pop
	final {
		$$->stmt = LangStmt::cons( LangStmt::ElseType, $3->stmtList );
	};

optional_else: 
	final {
		$$->stmt = 0;
	};

#
# Code LexExpression Lists.
#
nonterm code_expr_list
{
	ExprVect *exprVect;
};

code_expr_list:
	code_expr_list code_expr
	final {
		$$->exprVect = $1->exprVect;
		$$->exprVect->append( $2->expr );
	};
code_expr_list:
	code_expr
	final {
		$$->exprVect = new ExprVect;
		$$->exprVect->append( $1->expr );
	};

nonterm opt_code_expr_list uses code_expr_list;

opt_code_expr_list:
	code_expr_list
	final {
		$$->exprVect = $1->exprVect;
	};

opt_code_expr_list: 
	final {
		$$->exprVect = 0;
	};

#
# Type list
#

nonterm type_list
{
	TypeRefVect *typeRefVect;
};

type_list: type_list ',' type_ref
	final {
		$$->typeRefVect = $1->typeRefVect;
		$$->typeRefVect->append( $3->typeRef );
	};
type_list: type_ref
	final {
		$$->typeRefVect = new TypeRefVect;
		$$->typeRefVect->append( $1->typeRef );
	};

nonterm opt_type_list uses type_list;

opt_type_list: type_list
	final {
		$$->typeRefVect = $1->typeRefVect;
	};

opt_type_list: 
	final {
		$$->typeRefVect = 0;
	};


#
# Variable reference
#

nonterm var_ref
{
	LangVarRef *varRef;
};

var_ref: qual TK_Word
	final {
		$$->varRef = LangVarRef::cons( $2->loc, $1->qual, $2->data );
	};

nonterm qual
{
	QualItemVect *qual;
};

qual: qual TK_Word '.'
	final {
		$$->qual = $1->qual;
		$$->qual->append( QualItem( $2->loc, $2->data, QualItem::Dot ) );
	};
qual: qual TK_Word TK_RightArrow
	final {
		$$->qual = $1->qual;
		$$->qual->append( QualItem( $2->loc, $2->data, QualItem::Arrow ) );
	};
qual: 
	final {
		$$->qual = new QualItemVect;
	};

#
# Code expression
#

nonterm code_expr
{
	LangExpr *expr;
};

code_expr: code_expr TK_AmpAmp code_relational
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, OP_LogicalAnd, $3->expr );
	};

code_expr: code_expr TK_BarBar code_relational
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, OP_LogicalOr, $3->expr );
	};

code_expr: code_relational
	final {
		$$->expr = $1->expr;
	};

nonterm code_relational uses code_expr;

code_relational: code_relational TK_DoubleEql code_additive
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, OP_DoubleEql, $3->expr );
	};

code_relational: code_relational TK_NotEql code_additive
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, OP_NotEql, $3->expr );
	};

code_relational: code_relational '<' code_additive
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, '<', $3->expr );
	};

code_relational: code_relational '>' code_additive
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, '>', $3->expr );
	};

code_relational: code_relational TK_LessEql code_additive
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, OP_LessEql, $3->expr );
	};

code_relational: code_relational TK_GrtrEql code_additive
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, OP_GrtrEql, $3->expr );
	};


code_relational: code_additive
	final {
		$$->expr = $1->expr;
	};

nonterm code_additive uses code_expr;

code_additive: code_additive '+' code_multiplicitive
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, '+', $3->expr );
	};

code_additive: code_additive '-' code_multiplicitive
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, '-', $3->expr );
	};

code_additive: code_multiplicitive
	final {
		$$->expr = $1->expr;
	};

nonterm code_multiplicitive uses code_expr;

code_multiplicitive: code_multiplicitive '*' code_unary
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, '*', $3->expr );
	};

code_multiplicitive: code_multiplicitive '/' code_unary
	final {
		$$->expr = LangExpr::cons( $2->loc, $1->expr, '/', $3->expr );
	};

code_multiplicitive: code_unary
	final {
		$$->expr = $1->expr;
	};

nonterm code_unary uses code_expr;
code_unary: '!' code_factor
	final {
		$$->expr = LangExpr::cons( $1->loc, '!', $2->expr );
	};
code_unary: '$' code_factor
	final {
		$$->expr = LangExpr::cons( $1->loc, '$', $2->expr );
	};
code_unary: '^' code_factor
	final {
		$$->expr = LangExpr::cons( $1->loc, '^', $2->expr );
	};
code_unary: '%' code_factor
	final {
		$$->expr = LangExpr::cons( $1->loc, '%', $2->expr );
	};
code_unary: code_factor
	final {
		$$->expr = $1->expr;
	};

nonterm opt_capture uses var_def;

opt_capture: TK_Word ':'
	final {
		$$->objField = ObjectField::cons( $1->loc, 0, $1->data );
	};
opt_capture:
	final {
		$$->objField = 0;
	};

nonterm parse_cmd
{
	bool stop;
	InputLoc loc;
};

parse_cmd:
	KW_Parse 
	final {
		$$->stop = false;
		$$->loc = $1->loc;
	};

parse_cmd:
	KW_ParseStop
	final {
		$$->stop = true;
		$$->loc = $1->loc;
	};

nonterm code_factor uses code_expr;

code_factor: TK_Number
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( InputLoc(), LangTerm::NumberType, $1->data ) );
	};
code_factor: TK_Literal
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( InputLoc(), LangTerm::StringType, $1->data ) );
	};
code_factor: var_ref '(' opt_code_expr_list ')'
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( InputLoc(), $1->varRef, $3->exprVect ) );
	};
code_factor: var_ref
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( InputLoc(), LangTerm::VarRefType, $1->varRef ) );
	};
code_factor: KW_Match var_ref pattern
	final {
		$$->expr = match( $1->loc, $2->varRef, $3->list );
	};
code_factor: KW_New code_factor
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( InputLoc(), LangTerm::NewType, $2->expr ) );
	};
code_factor: 
	KW_Construct opt_capture type_ref opt_field_init constructor
	final {
		$$->expr = construct( $1->loc, $2->objField, $5->list,
				$3->typeRef, $4->fieldInitVect );
	};

code_factor: 
	parse_cmd opt_capture type_ref opt_field_init accumulate
	final {
		$$->expr = parseCmd( $1->loc, $1->stop, $2->objField,
				$3->typeRef, $4->fieldInitVect, $5->list );
	};
code_factor: 
	var_ref TK_LtLt accumulate
	final {
		$$->expr = send( $2->loc, $1->varRef, $3->list );
	};
code_factor: 
	KW_Send var_ref accumulate
	final {
		$$->expr = send( $1->loc, $2->varRef, $3->list );
	};
code_factor: KW_TypeId '<' type_ref '>'
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( $1->loc,
				LangTerm::TypeIdType, $3->typeRef ) );
	};
code_factor: type_ref KW_In var_ref
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( $2->loc,
				LangTerm::SearchType, $1->typeRef, $3->varRef ) );
	};
code_factor: KW_Nil
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( $1->loc, 
				LangTerm::NilType ) );
	};
code_factor: KW_True
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( $1->loc, 
				LangTerm::TrueType ) );
	};
code_factor: KW_False
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( $1->loc, 
				LangTerm::FalseType ) );
	};
code_factor: '(' code_expr ')'
	final {
		$$->expr = $2->expr;
	};
code_factor: KW_MakeTree '(' opt_code_expr_list ')'
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( $1->loc, 
				LangTerm::MakeTreeType, $3->exprVect ) );
	};
code_factor: KW_MakeToken '(' opt_code_expr_list ')'
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( $1->loc, 
				LangTerm::MakeTokenType, $3->exprVect ) );
	};
code_factor: KW_Deref code_expr
	final {
		$$->expr = LangExpr::cons( $1->loc, OP_Deref, $2->expr );
	};
code_factor: string
	final {
		$$->expr = LangExpr::cons( LangTerm::cons( InputLoc(), $1->list ) );
	};

nonterm opt_field_init uses field_init_list;

opt_field_init: '(' opt_field_init_list ')'
	final {
		$$->fieldInitVect = $2->fieldInitVect;
	};
opt_field_init: 
	final {
		$$->fieldInitVect = 0;
	};

nonterm opt_field_init_list uses field_init_list;

opt_field_init_list: field_init_list 
	final {
		$$->fieldInitVect = $1->fieldInitVect;
	};
opt_field_init_list: 
	final { 
		$$->fieldInitVect = 0;
	};

nonterm field_init_list
{
	FieldInitVect *fieldInitVect;
};

field_init_list: field_init_list field_init
	final {
		$$->fieldInitVect = $1->fieldInitVect;
		$$->fieldInitVect->append( $2->fieldInit );
	};
field_init_list: field_init
	final {
		$$->fieldInitVect = new FieldInitVect;
		$$->fieldInitVect->append( $1->fieldInit );
	};

nonterm field_init
{
	FieldInit *fieldInit;
};

field_init: code_expr
	final {
		$$->fieldInit = FieldInit::cons( InputLoc(), "_name", $1->expr );
	};

#
# Regular Expressions
#

nonterm opt_lex_join
{
	LexJoin *join;
};

opt_lex_join:
	lex_join opt_context
	final {
		$$->join = lexOptJoin( $1->join, $2->context );
	};

opt_lex_join:
	final {
		$$->join = 0;
	};

nonterm lex_join
{
	LexJoin *join;
};

lex_join: 
	lex_expr 
	final {
		$$->join = LexJoin::cons( $1->expression );
	};

nonterm opt_context
{
	LexJoin *context;
};

opt_context:
	'@' lex_join
	final
	{
		$$->context = $2->join;
	};

opt_context:
	final {
		$$->context = 0;
	};

nonterm lex_expr
{
	LexExpression *expression;
};

lex_expr: 
	lex_expr '|' lex_term_short
	final {
		$$->expression = LexExpression::cons( $1->expression, 
				$3->term, LexExpression::OrType );
	};
lex_expr: 
	lex_expr '&' lex_term_short
	final {
		$$->expression = LexExpression::cons( $1->expression, 
				$3->term, LexExpression::IntersectType );
	};
# This priority specification overrides the innermost parsing strategy which
# results ordered choice interpretation of the grammar.
lex_expr: 
	lex_expr '-' lex_term_short
	final {
		$$->expression = LexExpression::cons( $1->expression, 
				$3->term, LexExpression::SubtractType );
	};
lex_expr: 
	lex_expr TK_DashDash lex_term_short
	final {
		$$->expression = LexExpression::cons( $1->expression, 
				$3->term, LexExpression::StrongSubtractType );
	};
lex_expr: 
	lex_term_short
	final {
		$$->expression = LexExpression::cons( $1->term );
	};

nonterm lex_term_short
{
	LexTerm *term;
};

shortest lex_term_short;

lex_term_short: lex_term 
	final { $$->term = $1->term; };

nonterm lex_term
{
	LexTerm *term;
};

lex_term:
	lex_term lex_factor_label
	final {
		$$->term = LexTerm::cons( $1->term, $2->factorAug );
	};
lex_term:
	lex_term '.' lex_factor_label
	final {
		$$->term = LexTerm::cons( $1->term, $3->factorAug );
	};
lex_term:
	lex_term TK_ColonGt lex_factor_label
	final {
		$$->term = LexTerm::cons( $1->term, $3->factorAug, LexTerm::RightStartType );
	};
lex_term:
	lex_term TK_ColonGtGt lex_factor_label
	final {
		$$->term = LexTerm::cons( $1->term, $3->factorAug, LexTerm::RightFinishType );
	};
lex_term:
	lex_term TK_LtColon lex_factor_label
	final {
		$$->term = LexTerm::cons( $1->term,
				$3->factorAug, LexTerm::LeftType );
	};
lex_term:
	lex_factor_label
	final {
		$$->term = LexTerm::cons( $1->factorAug );
	};

nonterm lex_factor_label
{
	LexFactorAug *factorAug;
};

lex_factor_label: 
	factor_ep
	final {
		$$->factorAug = $1->factorAug;
	};

lex_factor_label: 
	TK_Word ':' lex_factor_label
	final {
		$$->factorAug = lexFactorLabel( $1->loc, $1->data, $3->factorAug );
	};

nonterm factor_ep
{
	LexFactorAug *factorAug;
};

factor_ep: 
	factor_aug
	final {
		$$->factorAug = $1->factorAug;
	};

nonterm factor_aug
{
	LexFactorAug *factorAug;
};

factor_aug:
	lex_factor_rep
	final {
		$$->factorAug = LexFactorAug::cons( $1->factorRep );
	};


# The fourth level of precedence. These are the trailing unary operators that
# allow for repetition.

nonterm lex_factor_rep
{
	LexFactorRep *factorRep;
};

lex_factor_rep:
	lex_factor_rep '*'
	final {
		$$->factorRep = LexFactorRep::cons( $2->loc, $1->factorRep, 
				0, 0, LexFactorRep::StarType );
	};
lex_factor_rep:
	lex_factor_rep TK_StarStar
	final {
		$$->factorRep = LexFactorRep::cons( $2->loc, $1->factorRep, 
				0, 0, LexFactorRep::StarStarType );
	};
lex_factor_rep:
	lex_factor_rep '?'
	final {
		$$->factorRep = LexFactorRep::cons( $2->loc, $1->factorRep, 
				0, 0, LexFactorRep::OptionalType );
	};
lex_factor_rep:
	lex_factor_rep '+'
	final {
		$$->factorRep = LexFactorRep::cons( $2->loc, $1->factorRep, 
				0, 0, LexFactorRep::PlusType );
	};
lex_factor_rep:
	lex_factor_rep '{' lex_factor_rep_num '}'
	final {
		$$->factorRep = LexFactorRep::cons( $2->loc, $1->factorRep, 
				$3->rep, 0, LexFactorRep::ExactType );
	};
lex_factor_rep:
	lex_factor_rep '{' ',' lex_factor_rep_num '}'
	final {
		$$->factorRep = LexFactorRep::cons( $2->loc, $1->factorRep, 
				0, $4->rep, LexFactorRep::MaxType );
	};
lex_factor_rep:
	lex_factor_rep '{' lex_factor_rep_num ',' '}'
	final {
		$$->factorRep = LexFactorRep::cons( $2->loc, $1->factorRep,
				$3->rep, 0, LexFactorRep::MinType );
	};
lex_factor_rep:
	lex_factor_rep '{' lex_factor_rep_num ',' lex_factor_rep_num '}'
	final {
		$$->factorRep = LexFactorRep::cons( $2->loc, $1->factorRep, 
				$3->rep, $5->rep, LexFactorRep::RangeType );
	};
lex_factor_rep:
	lex_factor_neg
	final {
		$$->factorRep = LexFactorRep::cons( 
				$1->factorNeg->loc, $1->factorNeg );
	};

nonterm lex_factor_rep_num
{
	int rep;
};

lex_factor_rep_num:
	TK_UInt
	final {
		$$->rep = lexFactorRepNum( $1->loc, $1->data );
	};


#
# The fifth level up in precedence. Negation.
#

nonterm lex_factor_neg
{
	LexFactorNeg *factorNeg;
};

lex_factor_neg:
	'!' lex_factor_neg
	final {
		$$->factorNeg = LexFactorNeg::cons( $1->loc,
				$2->factorNeg, LexFactorNeg::NegateType );
	};
lex_factor_neg:
	'^' lex_factor_neg
	final {
		$$->factorNeg = LexFactorNeg::cons( $1->loc,
				$2->factorNeg, LexFactorNeg::CharNegateType );
	};
lex_factor_neg:
	lex_rl_factor
	final {
		$$->factorNeg = LexFactorNeg::cons( $1->factor->loc, $1->factor );
	};

nonterm lex_rl_factor
{
	LexFactor *factor;
};

lex_rl_factor: 
	TK_Literal
	final {
		/* Create a new factor node going to a concat literal. */
		$$->factor = LexFactor::cons( Literal::cons( $1->loc,
				$1->data, Literal::LitString ) );
	};
lex_rl_factor: 
	lex_alphabet_num
	final {
		/* Create a new factor node going to a literal number. */
		$$->factor = LexFactor::cons( Literal::cons( $1->loc, 
				$1->data, Literal::Number ) );
	};
lex_rl_factor:
	TK_Word
	final {
		$$->factor = lexRlFactorName( $1->data, $1->loc );
	};
lex_rl_factor:
	TK_SqOpen lex_regular_expr_or_data TK_SqClose
	final {
		/* Create a new factor node going to an OR expression. */
		$$->factor = LexFactor::cons( ReItem::cons( $1->loc, $2->reOrBlock, ReItem::OrBlock ) );
	};
lex_rl_factor:
	TK_SqOpenNeg lex_regular_expr_or_data TK_SqClose
	final {
		/* Create a new factor node going to a negated OR expression. */
		$$->factor = LexFactor::cons( ReItem::cons( $1->loc, $2->reOrBlock, ReItem::NegOrBlock ) );
	};
lex_rl_factor:
	lex_range_lit TK_DotDot lex_range_lit
	final {
		/* Create a new factor node going to a range. */
		$$->factor = LexFactor::cons( Range::cons( $1->literal, $3->literal ) );
	};
lex_rl_factor:
	'(' lex_join ')'
	final {
		/* Create a new factor going to a parenthesized join. */
		$$->factor = LexFactor::cons( $2->join );
	};

nonterm lex_range_lit
{
	Literal *literal;
};

# Literals which can be the end points of ranges.
lex_range_lit:
	TK_Literal
	final {
		/* Range literas must have only one char. We restrict this in the parse tree. */
		$$->literal = Literal::cons( $1->loc, $1->data, Literal::LitString );
	};
lex_range_lit:
	lex_alphabet_num
	final {
		/* Create a new literal number. */
		$$->literal = Literal::cons( $1->loc, $1->data, Literal::Number );
	};

nonterm lex_alphabet_num uses token_data;

# Any form of a number that can be used as a basic machine. */
lex_alphabet_num:
	TK_UInt
	final { 
		$$->loc = $1->loc;
		$$->data = $1->data;
	};
lex_alphabet_num: 
	'-' TK_UInt
	final { 
		$$->loc = $1->loc;
		$$->data = '+';
		$$->data += $2->data;
	};
lex_alphabet_num: 
	TK_Hex
	final { 
		$$->loc = $1->loc;
		$$->data = $1->data;
	};

#
# Regular Expressions.
#


# The data inside of a [] expression in a regular expression. Accepts any
# number of characters or ranges. */
nonterm lex_regular_expr_or_data
{
	ReOrBlock *reOrBlock;
};

lex_regular_expr_or_data:
	lex_regular_expr_or_data lex_regular_expr_or_char
	final {
		$$->reOrBlock = lexRegularExprData( $1->reOrBlock, $2->reOrItem );
	};
lex_regular_expr_or_data:
	final {
		$$->reOrBlock = ReOrBlock::cons();
	};

# A single character inside of an or expression. Can either be a character or a
# set of characters.
nonterm lex_regular_expr_or_char
{
	ReOrItem *reOrItem;
};

lex_regular_expr_or_char:
	TK_ReChar
	final {
		$$->reOrItem = ReOrItem::cons( $1->loc, $1->data );
	};

lex_regular_expr_or_char:
	TK_ReChar TK_Dash TK_ReChar
	final {
		$$->reOrItem = ReOrItem::cons( $2->loc, $1->data[0], $3->data[0] );
	};

nonterm opt_commit
{
	bool commit;
};

opt_commit:
	final {
		$$->commit = false;
	};

opt_commit:
	KW_Commit
	final {
		$$->commit = true;
	};

#
# Grammar Finished
#

	write types;
	write data;
}%%

void ColmParser::initPda()
{
	%% write init;
}

int ColmParser::parseLangEl( int type, const Token *token )
{
	%% write exec;
	return errCount == 0 ? 0 : -1;
}

ostream &ColmParser::parse_error( int tokId, Token &token )
{
	/* Maintain the error count. */
	gblErrorCount += 1;

	cerr << token.loc.fileName << ":" << token.loc.line << ":" << token.loc.col << ": ";
	cerr << "at token ";
	if ( tokId < 128 )
		cerr << "\"" << ColmParser_lelNames[tokId] << "\"";
	else 
		cerr << ColmParser_lelNames[tokId];
	if ( token.data != 0 )
		cerr << " with data \"" << token.data << "\"";
	cerr << ": ";
	
	return cerr;
}

void ColmParser::parseInput( StmtList *stmtList )
{
	NamespaceQual *nspaceQual = NamespaceQual::cons( namespaceStack.top() );
	TypeRef *typeRef = TypeRef::cons( internal, nspaceQual, String("start"), RepeatNone );

	LangVarRef *varRef = LangVarRef::cons( internal, new QualItemVect, String("stdin") );
	LangExpr *expr = LangExpr::cons( LangTerm::cons( internal, LangTerm::VarRefType, varRef ) );

	ConsItem *consItem = ConsItem::cons( internal, ConsItem::ExprType, expr );
	ConsItemList *list = ConsItemList::cons( consItem );

	ObjectField *objField = ObjectField::cons( internal, 0, String("P") );

	expr = parseCmd( internal, false, objField, typeRef, 0, list );
	LangStmt *stmt = LangStmt::cons( internal, LangStmt::ExprType, expr );
	stmtList->append( stmt );
}

void ColmParser::printParseTree( StmtList *stmtList )
{
	QualItemVect *qual = new QualItemVect;
	qual->append( QualItem( internal, String( "P" ), QualItem::Dot ) );
	LangVarRef *varRef = LangVarRef::cons( internal, qual, String("tree") );
	LangExpr *expr = LangExpr::cons( LangTerm::cons( internal, LangTerm::VarRefType, varRef ) );

	ExprVect *exprVect = new ExprVect;
	exprVect->append( expr );
	LangStmt *stmt = LangStmt::cons( internal, LangStmt::PrintType, exprVect );
	stmtList->append( stmt );
}

void ColmParser::go()
{
	StmtList *stmtList = new StmtList;

	/* The token region */
	pushRegionSet( internal );

	tokenInstanceName( String( "hello" ) );

	curObjectDef = ObjectDef::cons( ObjectDef::UserType, curDefineId, pd->nextObjectId++ ); 

	Literal *literal = Literal::cons( internal, String( "'hello\n'" ), Literal::LitString );
	LexFactor *factor = LexFactor::cons( literal );
	LexFactorNeg *factorNeg = LexFactorNeg::cons( internal, factor );
	LexFactorRep *factorRep = LexFactorRep::cons( internal, factorNeg );
	LexFactorAug *factorAug = LexFactorAug::cons( factorRep );
	LexTerm *term = LexTerm::cons( factorAug );
	LexExpression *lexExpr = LexExpression::cons( term );
	LexJoin *join = LexJoin::cons( lexExpr );

	tokenInstance( internal, "hello", join, 0, false, false, false );

	popRegionSet();

	/* Grammar. */
	curDefineId = String( "start" );
	NtDef *ntDef = NtDef::cons( curDefineId, namespaceStack.top(),
				contextStack.top(), false );

	LelDefList *defList = new LelDefList;
		
	/* Production 1. */
	ProdElList *prodElList = new ProdElList;

	ProdEl *prodEl = prodElName( internal, String( "hello"), 
		NamespaceQual::cons(namespaceStack.top()), 0, RepeatNone, false );
	prodElList->append( prodEl );

	Production *def = production( internal, prodElList, false, 0, 0 );
	prodAppend( defList, def );

	/* Make. */
	cflDef( ntDef, curObjectDef, defList );

	parseInput( stmtList );

	printParseTree( stmtList );

	pd->rootCodeBlock = CodeBlock::cons( stmtList, 0 );
}
