# Main region.
lex
	token DEF / 'def' /
	token LEX / 'lex' /
	token END / 'end' /
	token TOKEN / 'token' /
	token RL / 'rl' /
	token IGNORE / 'ignore' /
	token PRINT / 'print' /
	token PRINT_XML / 'print_xml' /
	token PRINT_XML_AC / 'print_xml_ac' /
	token PARSE / 'parse' /
	token CONS / 'construct' | 'cons' /
	token SEND / 'send' /
	token NAMESPACE / 'namespace' /
	token FOR / 'for' /
	token IF / 'if' /
	token ELSIF / 'elsif' /
	token ELSE / 'else' /
	token IN / 'in' /
	token PARSER / 'parser' /
	token LIST / 'list' /
	token VECTOR / 'vector' /
	token MAP / 'map' /
	token PTR / 'ptr' /

	token LITERAL /'literal'/
	token CONTEXT /'context'/
	token NI /'ni'/

	token NIL / 'nil' /
	token TRUE / 'true' /
	token FALSE / 'false' /

	token id / 
		( 'a' .. 'z' | 'A' .. 'Z' | '_' ) .
		( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' ) *
	/

	token number / ( '0' .. '9' ) + /

	token lit /
		'\'' . ( ^( '\'' | '\\' ) | '\\' . any )* .  '\''
	/

	token DQ / '\"' /

	token SQOPEN /'['/
	token SQCLOSE /']'/
	token BAR /'|'/
	token FSLASH /'/'/ ni
	token COLON /':'/
	token DOUBLE_COLON /'::'/
	token DOT /'.'/
	token ARROW /'->'/
	token POPEN /'('/
	token PCLOSE /')'/
	token COPEN /'{'/
	token CCLOSE /'}'/
	token STAR /'*'/
	token PLUS /'+'/
	token QUESTION /'?'/
	token EQUALS /'='/
	token EQEQ /'=='/
	token COMMA /','/
	token LT /'<'/
	token GT /'>'/

	ignore / ( '\n' | '\t' | ' ' )+ /
	ignore / '#' . ( ^'\n' )* . '\n' /
end

lex
	token dlit / ( ^( '\"' | '\\' ) | '\\' . any )+ /
	token TDQ / '\"' /
end

lex
	token lex_id / 
		( 'a' .. 'z' | 'A' .. 'Z' | '_' ) .
		( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' ) *
	/

	token lex_number / ( '0' .. '9' )+ /
	token lex_lit / '\'' . ( ^( '\'' | '\\' ) | '\\' . any )* .  '\'' /

	token LEX_DOT /'.'/
	token LEX_BAR /'|'/
	token LEX_POPEN /'('/
	token LEX_PCLOSE /')'/
	token LEX_STAR /'*'/
	token LEX_STARSTAR /'**'/
	token LEX_QUESTION /'?'/
	token LEX_PLUS /'+'/
	token LEX_CARET /'^'/
	token LEX_DOTDOT /'..'/
	token LEX_SQOPEN_POS /'['/ ni
	token LEX_SQOPEN_NEG /'[^'/ ni
	token LEX_FSLASH ni /'/'/

	ignore / 
		( '\n' | '\t' | ' ' ) .
		( '\n' | '\t' | ' ' )* 
	/

	ignore / '#' . ( ^'\n' )* . '\n' /
end

lex
	token RE_DASH / '-' /
	token RE_CHAR / ^( '\\' | '-' | ']' ) | '\\' . any /
	token RE_SQCLOSE / ']' /
end

def start
	[RootItemList: root_item*]

def root_item
	[RlDef: rl_def]
|	[LiteralDef: literal_def]
|	[TokenDef: token_def]
|	[IgnoreDef: ignore_def]
|	[CflDef: cfl_def]
|	[RegionDef: region_def]
|	[ContextDef: context_def]
|	[NamespaceDef: namespace_def]
#|	[function_def]
#|	[iter_def]
#|	[global_def]
#|	[export_def]
|	[Statement: statement]
#|	[pre_eof]
#|	[precedence]
#|	[typedef]

def context_item
	[ContextVarDef: context_var_def]
|	[LiteralDef: literal_def]
|	[RlDef: rl_def]
|	[TokenDef: token_def]
|	[IgnoreDef: ignore_def]
|	[CflDef: cfl_def]
|	[RegionDef: region_def]
|	[ContextDef: context_def]
#|	[function_def]
#|	[iter_def]
#|	[export_def]
#|	[pre_eof]
#|	[precedence]

def context_var_def
	[VarDef: var_def]

def context_def
	[CONTEXT Name: id ContextItemList: context_item* END]

def literal_def
	[LITERAL LiteralList: literal_list]

def literal_list
	[LiteralList: literal_list COMMA LiteralItem: literal_item]
|	[LiteralItem: literal_item]

def literal_item
	[NiLeft: opt_no_ignore Lit: lit NiRight: opt_no_ignore]

def opt_no_ignore
	[Ni: NI]
|	[]

def namespace_def
	[NAMESPACE Name: id RootItemList: root_item* END]

def cfl_def
	[DEF DefId: id ProdList: prod_list]

def region_def
	[LEX RootItemList: root_item* END]

def rl_def
	[RL Id: id FSLASH Expr: lex_expr LEX_FSLASH]

def token_def
	[TOKEN Id: id FSLASH Expr: lex_expr LEX_FSLASH]

def ignore_def
	[IGNORE FSLASH Expr: lex_expr LEX_FSLASH]

def prod_el
	[OptName: opt_prod_name Id: id OptRepeat: opt_prod_repeat]
|	[OptName: opt_prod_name Lit: lit OptRepeat: opt_prod_repeat]

def opt_prod_name
	[Name: id COLON]
|	[]

def opt_prod_repeat
	[Star: STAR]
|	[]

def prod_el_list
	[ProdElList: prod_el_list ProdEl: prod_el]
|	[]

def prod
	[SQOPEN ProdElList: prod_el_list SQCLOSE OptReduce: opt_reduce]

def opt_reduce
	[COPEN LangStmtList: lang_stmt_list CCLOSE]
|	[]

def prod_list
	[ProdList: prod_list BAR Prod: prod]
|	[Prod: prod]

def statement
	[Print: print_stmt]
|	[Expr: expr_stmt]
|	[VarDef: var_def OptDefInit: opt_def_init]
|	[FOR ForDecl: id COLON TypeRef: type_ref IN IterCall: iter_call BlockOrSingle: block_or_single]
|	[IF IfExpr: code_expr BlockOrSingle: block_or_single ElsifList: elsif_list]
|	[LhsVarRef: var_ref EQUALS CodeExpr: code_expr]

def elsif_list
	[ElsifClause: elsif_clause ElsifList: elsif_list]
|	[OptionalElse: optional_else]

def elsif_clause
	[ELSIF ElsifExpr: code_expr BlockOrSingle: block_or_single]

def optional_else
	[ELSE BlockOrSingle: block_or_single]
|	[]

def iter_call
	[VarRef: var_ref POPEN CodeExprList: code_expr* PCLOSE]
|	[Id: id]

def block_or_single
	[COPEN LangStmtList: lang_stmt_list CCLOSE]
|	[Statement: statement]

def lang_stmt_list
	[StmtList: statement*]

def opt_def_init
	[EQUALS CodeExpr: code_expr]
|	[]

def var_def
	[Id: id COLON TypeRef: type_ref]

def print_stmt
	[Tree: PRINT POPEN CodeExprList: code_expr* PCLOSE]
|	[Xml: PRINT_XML POPEN CodeExprList: code_expr* PCLOSE]
|	[XmlAc: PRINT_XML_AC POPEN CodeExprList: code_expr* PCLOSE]

def expr_stmt
	[CodeExpr: code_expr]

def code_expr
	[Relational: code_relational]

def code_relational
	[Relational: code_relational EqEq: EQEQ Additive: code_additive]
|	[Additive: code_additive]

def code_additive
	[Factor: code_factor]

def code_factor
	[Number: number]
|	[Lit: lit]
|	[VarRef: var_ref POPEN CodeExprList: code_expr* PCLOSE]
|	[VarRef: var_ref]
|	[Nil: NIL]
|	[True: TRUE]
|	[False: FALSE]
|	[POPEN ParenCodeExpr: code_expr PCLOSE]
|	[Send: SEND ToVarRef: var_ref Accumulate: accumulate]
|	[Parse: PARSE OptCapture: opt_capture TypeRef: type_ref
		OptFieldInit: opt_field_init Accumulate: accumulate]
|	[Cons: CONS OptCapture: opt_capture TypeRef: type_ref
		OptFieldInit: opt_field_init Constructor: constructor]

def type_ref
	[RegionQual: region_qual DirectId: id OptRepeat: opt_repeat]
|	[PTR RegionQual: region_qual PtrId: id OptRepeat: opt_repeat]
|	[MAP LT MapKeyType: type_ref MapValueType: type_ref GT]
|	[LIST LT ListType: type_ref GT]
|	[VECTOR LT VectorType: type_ref GT]
|	[PARSER LT ParserType: type_ref GT]

def region_qual
	[RegionQual: region_qual Id: id DOUBLE_COLON]
|	[]

def opt_repeat
	[Star: STAR]
|	[Plus: PLUS]
|	[Question: QUESTION]
|	[]

def opt_capture
	[Id: id COLON]
|	[]

def opt_field_init
	[POPEN FieldInitList: field_init* PCLOSE]
|	[]

def field_init
	[CodeExpr: code_expr]

#
# Constructor List
#

def cons_el
#	[region_qual TK_Literal]
#|	['"' lit_cons_el_list '"']
	[CodeExpr: code_expr]

def lit_cons_el
	[DLit: dlit]
#|	['[' cons_el_list ']']

def cons_top_el
	[DQ LitConsElList: lit_cons_el* TDQ]
|	[SQOPEN ConsElList: cons_el* SQCLOSE]

def cons_list
	[ConsTopEl: cons_top_el ConsList: cons_list]
|	[ConsTopEl: cons_top_el]

def constructor
	[ConsList: cons_list]

#
# Accumulate
#

def accum_el
	[CodeExpr: code_expr]
#|	['"' lit_accum_el* '"']

def lit_accum_el
	[DLit: dlit]
#|	['[' accum_el_list ']']

def accum_top_el
	[DQ LitAccumElList: lit_accum_el* TDQ]
|	[SQOPEN AccumElList: accum_el* SQCLOSE]

def accum_list
	[AccumTopEl: accum_top_el AccumList: accum_list]
|	[AccumTopEl: accum_top_el]

def accumulate
	[AccumList: accum_list]


def var_ref
	[Qual: qual Id: id]

def qual
	[Qual: qual Id: id Dot: DOT]
|	[Qual: qual Id: id Arrow: ARROW]
|	[]

def lex_expr
	[Expr: lex_expr LEX_BAR Term: lex_term]
|	[Term: lex_term]

def lex_term
	[Term: lex_term LEX_DOT FactorRep: lex_factor_rep]
|	[Term: lex_term FactorRep: lex_factor_rep]
|	[FactorRep: lex_factor_rep]

def lex_factor_rep
	[FactorRep: lex_factor_rep Star: LEX_STAR]
|	[FactorRep: lex_factor_rep StarStar: LEX_STARSTAR]
|	[FactorRep: lex_factor_rep Plus: LEX_PLUS]
|	[FactorRep: lex_factor_rep Question: LEX_QUESTION]
|	[FactorNeg: lex_factor_neg]

def lex_factor_neg
	[LEX_CARET FactorNeg: lex_factor_neg]
|	[Factor: lex_factor]

def lex_factor
	[Literal: lex_lit]
|	[Id: lex_id]
|	[LEX_POPEN Expr: lex_expr LEX_PCLOSE]
|	[Low: lex_lit LEX_DOTDOT High: lex_lit]
|	[LEX_SQOPEN_POS PosData: reg_or_data RE_SQCLOSE]
|	[LEX_SQOPEN_NEG NegData: reg_or_data RE_SQCLOSE]

def reg_or_data
	[Data: reg_or_data Char: reg_or_char]
|	[]

def reg_or_char
	[Char: RE_CHAR]
|	[Low: RE_CHAR RE_DASH High: RE_CHAR]
