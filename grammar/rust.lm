lex
	literal `fn `use `let `mut `if `else `struct
	literal `loop `while `for `in
	literal `true `false
	literal `ref `match `as `impl
	literal `crate `self `return `type
	literal `pub `const `unsafe

	literal `; `:: `( `) `{ `} `. `, `@
	literal `[ `] `:
	literal `-> `=>
	literal `< `>
	literal `?

	literal `- `+ `/ `* `% `! `&mut

	literal `#

	literal `^ `| `&

	literal `>> `<<
	literal `== `!= `>= `<=
	literal `|| `&&
	literal `.. `..= `...
	literal `=
	literal `+= `-= `*= `/= `%= `&= `|= `^= `<<= `>>=

	literal `_

	token id       / [A-Za-z_] [A-Za-z_0-9]* /
	token string   / '"' ( [^\"] | '\\' any )* '"' /
	token char     / "'" ( [^\'] | '\\' any )  "'" /
	token lifetime / "'" id /
	token number   / [0-9] [_0-9]* /
	token float    / [0-9]+ '.' [0-9]+ /

	ignore / "//" [^\n]* '\n' /
	ignore / "/*" any* :>> "*/" /
	ignore / [ \t\n]+ /
end

namespace attr
	lex
		token id       / [A-Za-z_] [A-Za-z_0-9]* /
		token string   / '"' ( [^\"] | '\\' any )* '"' /
		token char     / "'" ( [^\'] | '\\' any )  "'" /
		token lifetime / "'" id /
		token number   / [0-9]+ /
		token float    / [0-9]+ '.' [0-9]+ /

		literal `[ `]

		ignore / "//" [^\n]* '\n' /
		ignore / "/*" any* :>> "*/" /
		ignore / [ \t\n]+ /

		token sym      / any /
	end

	def item
		[id]
	|	[string]
	|	[char]
	|	[lifetime]
	|	[number]
	|	[float]
	|	[sym]
	|	[_list]

	def _list
		[ `[ item* `] ]
end

def attribute
	[`# `! attr::_list]
|	[`# attr::_list]

namespace macro
	lex
		token id       / [A-Za-z_] [A-Za-z_0-9]* /
		token string   / '"' ( [^\"] | '\\' any )* '"' /
		token char     / "'" ( [^\'] | '\\' any )  "'" /
		token lifetime / "'" id /
		token number   / [0-9]+ /
		token float    / [0-9]+ '.' [0-9]+ /

		literal `( `) `[ `] `{ `} `;

		ignore / "//" [^\n]* '\n' /
		ignore / "/*" any* :>> "*/" /
		ignore / [ \t\n]+ /

		token sym      / any /
	end

	def item
		[id]
	|	[string]
	|	[char]
	|	[lifetime]
	|	[number]
	|	[float]
	|	[sym]
	|	[_list]

	def _list
		[ `( item* `) `; ]
	|	[ `[ item* `] `; ]
	|	[ `{ item* `} ]
end

def macro_invocation
	[simple_path `! macro::_list]

#
# Use statments
#

def sp_tail
	[sp_tail `:: id]
|	[]

def simple_path
	[id sp_tail]

def use_list_tail
	[use_list_tail `, use_tree]
|	[]

def use_path_opt
	[simple_path `::]
|	[`::]
|	[]

def use_as_opt
	[`as id]
|	[`as `_]
|	[]

def use_tree
	[use_path_opt `*]
|	[use_path_opt `{ use_tree use_list_tail `}]
|	[simple_path use_as_opt]

def use_declaration
	[`use use_tree `;]

#
# Patterns
#

def literal_pattern
	[`true]
|	[`false]
|	[char]
|	[string]
|	[number]
|	[float]

def identifier_pattern
	[opt_ref opt_mut id]
|	[opt_ref opt_mut id `@ pattern]

def wildcard_pattern
	[`_]

def range_pattern_bound
	[literal_pattern]

def range_pattern
	[range_pattern_bound `..= range_pattern_bound]
|	[range_pattern_bound `... range_pattern_bound]

def reference_pattern
	[`& opt_mut pattern]
|	[`&& opt_mut pattern]

#
# struct pattern
#
def struct_pattern_field
	[number `: pattern]
|	[id `: pattern]
|	[opt_ref opt_mut id]

def struct_pattern_fields
	[struct_pattern_fields `, struct_pattern_field]
|	[struct_pattern_field]

def struct_pattern_et_cetera
	[`..]

def struct_pattern_elements
	[struct_pattern_fields]
|	[struct_pattern_fields `, ]
|	[struct_pattern_fields `, struct_pattern_et_cetera]
|	[struct_pattern_et_cetera]

def opt_struct_pattern_elements
	[struct_pattern_elements]
|	[]

def struct_pattern
	[path_in_expression `{ opt_struct_pattern_elements `}]

def opt_comma
	[`,]
|	[]

def tuple_struct_item
	[pattern]
|	[`..]

def tuple_struct_items
	[tuple_struct_items `, tuple_struct_item]
|	[tuple_struct_item]

def tuple_struct_pattern
	[path_in_expression `( tuple_struct_items opt_comma `)]

def tuple_pattern_item
	[pattern]
|	[`..]

def tuple_pattern_items
	[tuple_pattern_items `, tuple_pattern_item]
|	[tuple_pattern_item]

def tuple_pattern
	[`( tuple_pattern_item `, `)]
|	[`( tuple_pattern_item `, tuple_pattern_items opt_comma `)]

def grouped_pattern
	[`( pattern `)]

def pattern_list
	[pattern_list `, pattern]
|	[pattern]

def slice_pattern
	[`[ pattern `, `]]
|	[`[ pattern `, pattern_list opt_comma `]]

def path_pattern
	[path_in_expression]
|	[qualified_path_in_expression]

def pattern
	[literal_pattern]
|	[identifier_pattern]
|	[wildcard_pattern]
|	[range_pattern]
|	[reference_pattern]
|	[struct_pattern]
|	[tuple_struct_pattern]
|	[tuple_pattern]
|	[grouped_pattern]
|	[slice_pattern]
|	[path_pattern]

# Range Pattern


#
# Match Expressions.
#

def match_expression
	[`match expression `{ match_arms? `}]

def match_arms_last
	[match_arm `=> block_expression `, ?]
|	[match_arm `=> expression `, ?]

def match_arms_first_case
	[match_arm `=> block_expression `, ?]
|	[match_arm `=> expression `,]

def match_arms_first_list
	[match_arms_first_list match_arms_first_case]
|	[]

def match_arms
	[match_arms_first_list match_arms_last]

def match_arm
	[match_arm_patterns opt_match_arm_guard]

def match_arms_pattern_tail
	[match_arms_pattern_tail `| pattern]
|	[]

def opt_bar
	[`|]
|	[]

def match_arm_patterns
	[opt_bar pattern match_arms_pattern_tail]

def opt_match_arm_guard
	[`if expression]
|	[]

#
# Return expressions
#
def return_expression
	[`return]
|	[`return expression]

#
# Generic Args
#

def lifetime_tail
	[lifetime_tail `, lifetime]
|	[]

def lifetime_list
	[lifetime lifetime_tail]

def opt_type_params
	[`< lifetime_list `>]
|	[`< type_list `>]
|	[`< lifetime_list `, type_list `>]
|	[]


#
# Function declaration
#

def opt_return
	[]
|	[ `-> type]

def function_qualifiers
	[`const]
|	[`const `unsafe]
|	[`unsafe]
|	[]

def function_param
	[pattern `: type]

def func_param_tail
	[func_param_tail `, function_param]
|	[]

def function_parameters
	[function_param func_param_tail opt_comma]

def function
	[function_qualifiers `fn id opt_generics `( function_parameters `) opt_return block_expression]

#
# Method declaration
#

def self_param
	[opt_mut `self]
|	[`& opt_mut `self]
|	[`& lifetime opt_mut `self]
|	[opt_mut `self `: type]

def opt_field_list
	[`, field_list]
|	[]

def method
	[`fn id opt_generics `( self_param opt_field_list `) opt_return block_expression]

#
# Types
#

def qual_tail
	[qual_tail `:: id]
|	[]

def qual_id
	[id qual_tail]

def type_id
	[id opt_type_params]

def type_path_tail
	[type_path_tail `:: type_id]
|	[]

def opt_sep
	[`::]
|	[]

def type_path
	[opt_sep type_id type_path_tail]

def opt_lifetime
	[lifetime]
|	[]

def array_type
	[`[ type `; expression `]]

def slice_type
	[`[ type `]]

def raw_pointer_type
	[`* `mut type_no_bounds]
|	[`* `const type_no_bounds]

def type
	[type_no_bounds]

def type_no_bounds
	[type_path]
|	[array_type]
|	[slice_type]
|	[raw_pointer_type]
|	[`& opt_lifetime type]
|	[`&mut type]
|	[`& lifetime `mut type]
|	[`( `)]

def type_list
	[type_list `, type]
|	[type]

def opt_mut
	[`mut]
|	[]

def opt_ref
	[`ref]
|	[]

def opt_type
	[`: type]
|	[]

def block_expr
	[`{ statements `}]

def let_rvalue
	[expression]
|	[`{ statements `}]

def let_stmt
	[`let pattern opt_type `= let_rvalue]

def expr_tail
	[expr_tail `, expression]
|	[]

def expr_list
	[expression expr_tail]
|	[]

def _construct
	[id `: expression]

def cons_plus
	[cons_plus `, _construct]
|	[_construct]

def cons_list
	[cons_plus opt_comma]
|	[]


#
# Expression
#

def path_ident_segment
	[id]
|	[`self]
|	[`crate]

def path_expr_segment
	[path_ident_segment]
#|	[path_ident_segment `:: generic_args]

def pie_tail
	[pie_tail `:: path_expr_segment]
|	[]

def opt_path_sep
	[`::]
|	[]

def path_in_expression
	[opt_path_sep path_expr_segment pie_tail]

def qualified_path_in_expression
	[`< type `>]

def path_expression
	[path_in_expression]
|	[qualified_path_in_expression]

def tuple_expression
	[`( expression `, `)]
|	[`( expression `, expr_list opt_comma `)]

def array_expression
	[`[ expr_list opt_comma `]]
|	[ `[ number `; number `]]

# Doesn't really belong in expressions. Macros are a whole pass before. Here
# for now.
def opt_macro
	[`!]
|	[]

def paths
	[path_expression]
|	[char]
|	[string]
|	[number]
|	[float]
|	[id `{ cons_list `}]
|	[`( `)]
|	[`true]
|	[`false]
|	[`( expression `)]
|	[tuple_expression]
|	[array_expression]

def func_index
	[func_index `. qual_id `( expr_list `)]
|	[func_index `. id]
|	[func_index `. number]
|	[func_index opt_macro `( expr_list `)]
|	[func_index opt_macro `[ expr_list `]]
|	[paths]

def question
	[question `?]
|	[func_index]

def unary
	[question]
|	[`- unary]
|	[`* unary]
|	[`! unary]
|	[`& unary]
|	[`&mut unary]
|	[`mut unary]

def as
	[unary]
|	[unary `as type_no_bounds]

def mult
	[mult `* as]
|	[mult `/ as]
|	[mult `% as]
|	[as]

def add_sub
	[add_sub `- mult]
|	[add_sub `+ mult]
|	[mult]

def shift
	[shift `>> add_sub]
|	[shift `<< add_sub]
|	[add_sub]

def bitwise_and
	[bitwise_and `& shift]
|	[shift]

def bitwise_xor
	[bitwise_xor `^ bitwise_and]
|	[bitwise_and]

def bitwise_or
	[bitwise_or `| bitwise_xor]
|	[bitwise_xor]

def comp_op
	[`==] |	[`!=]
|	[`>]  |	[`<]
|	[`>=] |	[`<=]

def comparison
	[comparison comp_op bitwise_or]
|	[bitwise_or]

def lazy_conjunction
	[lazy_conjunction `&& comparison]
|	[comparison]

def lazy_disjunction
	[lazy_disjunction `|| lazy_conjunction]
|	[lazy_conjunction]

def range_expression
	[range_expression `..  lazy_disjunction]
|	[lazy_disjunction `..]
|	[`.. lazy_disjunction]
|	[`..]
|	[range_expression `..= lazy_disjunction]
|	[`..= lazy_disjunction]
|	[lazy_disjunction]

# Evaluates right to left.
def assignment_expression
	[range_expression `= assignment_expression]
|	[range_expression]

def compound_op
	[`+=] | [`-=] | [`*=] | [`/=] | [`%=]
|	[`&=] | [`|=] | [`^=] | [`<<=] | [`>>=]

# Evaluates right to left. 
def compound_expression
	[assignment_expression compound_op compound_expression]
|	[assignment_expression]

def expression
	[expression_without_block]
|	[expression_with_block]

#
# Statements
#

def block_expression
	[`{ statements? `}]

def let_statement
	[`let pattern opt_type `= let_rvalue `;]

def expression_without_block
	[compound_expression `? ?]
|	[return_expression]

def expression_with_block
	[block_expression]
|	[loop_expression]
|	[if_expression]
|	[if_let_expression]
|	[match_expression]

def expression_statement
	[expression_without_block `;]
|	[expression_with_block]

def statement
	[`;]
|	[let_statement]
|	[expression_statement]
|	[use_declaration]

def statements
	[statement+]
|	[statement+ expression_without_block]
|	[expression_without_block]

def loop_expression
	[`loop block_expression]
|	[`while expression block_expression]
|	[`while `let match_arm_patterns `= expression block_expression]
|	[`for pattern `in expression block_expression]

def if_expression
	[`if expression block_expression opt_else_expression]

def opt_else_expression
	[`else block_expression]
|	[`else if_expression]
|	[`else if_let_expression]
|	[]

def if_let_expression
	[`if `let match_arm_patterns `= expression block_expression]

def field
	[id `: type]

def field_plus
	[field_plus `, field]
|	[field]

def field_list
	[field_plus]
|	[]

#
# Lifetime Params
#

def lifetime_param
	[lifetime]

def lifetime_param_tail
	[lifetime_param_tail `, lifetime_param]
|	[]

def lifetime_param_list
	[lifetime_param lifetime_param_tail]

#
# Type Params
#

def opt_eq_type
	[`= type]
|	[]

def type_param
	[id opt_eq_type]

def type_param_tail
	[type_param_tail `, type_param]
|	[]

def type_param_list
	[type_param type_param_tail]

#
# Generics
#

def generic_params
	[lifetime_param_list `, type_param_list]
|	[lifetime_param_list]
|	[type_param_list]
|	[]

def opt_generics
	[`< generic_params `>]
|	[]

#
# Where clause
#
def opt_where_clause
	[]

#
# Tuple List
#

def tuple_field_tail
	[tuple_field_tail `, type]
|	[]

def tuple_field_list
	[type tuple_field_tail]
|	[]

#
# Structure
#

def structure
	[`struct id opt_generics `{ field_list `}]
|	[`struct id opt_generics `;]
|	[`struct id opt_generics `( tuple_field_list `) `; ]

#
# Implementation
#

def inherent_impl_item
	[function]
|	[method]

def inherent_impl
	[`impl opt_generics type `{ inherent_impl_item* `}]

def trait_impl
	[]

def implementation
	[inherent_impl]
#|	[trait_impl]

def type_alias
	[`type id opt_generics opt_where_clause `= type `;]

def visibiltiy
	[`pub]

def const_item
	[`const id `: type `= expression `;]
|	[`const `_ `: type `= expression `;]

#
# All Items.
#

def item
	[`pub ? vis_item]

def vis_item
	[attribute] commit
|	[macro_invocation] commit
|	[function] commit
|	[structure] commit
|	[implementation] commit
|	[use_declaration] commit
|	[type_alias] commit
|	[const_item] commit

def program
	[item*]

