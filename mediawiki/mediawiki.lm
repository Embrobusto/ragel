def open_item
	str type
	int num
	[]

list open_stack [open_item]
global open_stack OpenStack = construct open_stack []
open_item Sentinal = construct open_item( type: '** SENTINAL **', num: 1 ) []
OpenStack.push( Sentinal )

lex start
{
	token stray_close //

	token ocurly /'{'+/
	{
		open_item OI = construct open_item( type: '{', num: match_length ) []
		OpenStack.push( OI )
		int i = 0
		while ( i < match_length ) {
			send( make_token( typeid ocurly, pull(stdin, 1 ) ) )
			i = i + 1
		}
	}

	token ccurly1 //
	token ccurly2 //
	token ccurly3 //
	token missing_curly //

	token tmp1 /'}'+/
	{
		if OpenStack.length > 0 && OpenStack.tail.type == '{' {
			int length = 3
			if ( length > match_length )
				length = match_length

			open_item Tail = OpenStack.pop()
			if ( length > Tail.num )
				length = Tail.num

			if ( length == 1 )
				send( make_token( typeid ccurly1, pull( stdin, 1 ) ) )
			else if ( length == 2 )
				send( make_token( typeid ccurly2, pull( stdin, 2 ) ) )
			else if ( length == 3 )
				send( make_token( typeid ccurly3, pull( stdin, 3 ) ) )

			Tail.num = Tail.num - length

			if ( Tail.num > 0 )
				OpenStack.push( Tail )
		}
		else {
			send( make_token( typeid stray_close, pull( stdin, match_length ) ) )
		}
	}
	
	token osquare /'['+/
	{
		open_item OI = construct open_item( type: '[', num: match_length ) []
		OpenStack.push( OI )
		int i = 0
		while ( i < match_length ) {
			send( make_token( typeid osquare, pull(stdin, 1 ) ) )
			i = i + 1
		}
	}

	token csquare1 //
	token csquare2 //
	token missing_square //

	token tmp2 /']'+/
	{
		if OpenStack.length > 0 && OpenStack.tail.type == '[' {
			int length = 2
			if ( length > match_length )
				length = match_length

			open_item Tail = OpenStack.pop()
			if ( length > Tail.num )
				length = Tail.num

			if ( length == 1 )
				send( make_token( typeid csquare1, pull( stdin, 1 ) ) )
			else if ( length == 2 )
				send( make_token( typeid csquare2, pull( stdin, 2 ) ) )

			Tail.num = Tail.num - length

			if ( Tail.num > 0 )
				OpenStack.push( Tail )
		}
		else {
			send( make_token( typeid stray_close, pull( stdin, match_length ) ) )
		}
	}
	
	literal '|'
	token char /any/

	preeof {
		while ( OpenStack.length > 0 ) {
			open_item Tail = OpenStack.pop()
			int i
			if ( Tail.type == '{' ) {
				i = 0
				while ( i < Tail.num ) {
					send( make_token( typeid missing_curly, '}' ) )
					i = i + 1
				}
			}
			else if ( Tail.type == '[' ) {
				i = 0
				while ( i < Tail.num ) {
					send( make_token( typeid missing_square, ']' ) )
					i = i + 1
				}
			}
		}
	}
}

#
# Internal Links
#


lex el_prefix
{
	literal 'http:'
	literal 'ftp:'
	literal 'mailto:'
}

def el_prefix
	['http:']
|	['ftp:']
|	['mailto:']

def external_link
	[osquare item* csquare1]

def internal_link
	[osquare osquare item* csquare2]

def unclosed_square
	[osquare item* missing_square]

#
# Templates
#

def sing_template
	[ocurly item* ccurly1]

def template
	[ocurly ocurly item* ccurly2]

def parameter
	[ocurly ocurly ocurly item* ccurly3] 

def unclosed_curly
	[ocurly item* missing_curly]

#
# Template Parameters
#


def U1 []
def U2 []
def U3 []

def item
	[external_link]
|	[internal_link]
|	[unclosed_curly]
|	[sing_template]
|	[template]
|	[parameter]
|	[unclosed_curly]
|	[stray_close]
|	[osquare]
|	['|']
|	[char]

def start 
	[item*]

start S = parse start(stdin)
for I: internal_link in S
	print( I, '\n' )
print_xml( S )
#print_xml( OpenStack )
