namespace inline
	lex 
		literal `fpc `fc  `fcurs `ftargs
			`fentry `fhold `fexec `fgoto `fnext
			`fcall `fret `fbreak `fncall `fnret `fnbreak

		token ident /ident/
		token number /digit+/
		token hex_number /'0x' [0-9a-fA-F]+/
		token dec_number /'0x' [0-9a-fA-F]+/

		token comment
			/ ruby_comment /

		token string
			/ s_literal | d_literal | host_re_literal /

		token whitespace
			/ ( [ \t] | NL )+ /

		literal 
			`{ `} `:: `* `, `( `) `;

		token var_ref
			/ "$" [a-zA-Z_][a-zA-Z_0-9]* /
			{
				if GblActionParams 
				{
					input->push( make_token(
							typeid<var_ref>, input->pull( match_length ) ) )
				}
				else
				{
					# Just pull one char. Don't consume the word because it may
					# be a keyword.
					input->push( make_token(
							typeid<c_any>, input->pull( 1 ) ) )
				}
			}

		token c_any
			/ any /
	end

	def inline_expr
		[expr_item_list] :List

	def expr_item_list
		[expr_item_list expr_item] :Rec
	|	[] :Empty

	def expr_item
		[expr_any] :ExprAny
	|	[expr_symbol] :ExprSymbol
	|	[expr_interpret] :ExprInterpret

	def expr_any
		[whitespace] :WS
	|	[comment] :Comment
	|	[string] :String
	|	[number] :Number
	|	[hex_number] :Hex
	|	[ident] :Ident
	|	[c_any] :Any

	def expr_symbol
		[`,] :Comma | [`(] :Open | [`)] :Close | [`*] :Star | [`::] :DoubleColon

	def expr_interpret
		[`fpc] :Fpc
	|	[`fc] :Fc
	|	[`fcurs] :Fcurs
	|	[`ftargs]  :Ftargs
	|	[`fentry `( state_ref::state_ref state_ref::`)] :Fentry
	|	[var_ref] :VarRef

	def inline_block
		[block_item_list] :List
	
	def block_item_list
		[block_item block_item_list] :Rec
	|	[] :Base
	
	def block_item
		[expr_any] :ExprAny
	|	[block_symbol] :BlockSymbol
	|	[block_interpret] :BlockInterpret
	|	[`{ inline_block `}] :RecBlock

	def block_symbol
		[`,] :B1 | [`;] :B2 | [`(] :B3 | [`)] :B4 | [`*] :B5 | [`::] :B6

	def block_interpret
		[expr_interpret] :ExprInterpret
	|	[`fhold whitespace? `;] :Fhold
	|	[`fgoto whitespace? `* inline_expr `;] :FgotoExpr
	|	[`fnext whitespace? `* inline_expr `;] :FnextExpr
	|	[`fcall whitespace? `* inline_expr `;] :FcallExpr
	|	[`fncall whitespace? `* inline_expr `;] :FncallExpr
	|	[`fexec inline_expr `;] :Fexec
	|	[`fgoto state_ref::state_ref state_ref::`;] :FgotoSr
	|	[`fnext state_ref::state_ref state_ref::`;] :FnextSr
	|	[`fcall state_ref::state_ref state_ref::`;] :FcallSr
	|	[`fncall state_ref::state_ref state_ref::`;] :FncallSr
	|	[`fret `;] :Fret
	|	[`fnret `;] :Fnret
	|	[`fbreak `;] :Fbreak
	|	[`fnbreak `;] :Fnbreak
end


namespace host
	lex 
		literal `%%{

		token close_inc /'}--%%'/
		{
			input->push( make_token( typeid<close_inc>, input->pull( match_length ) ) )
			restoreGlobals()
		}

		token close_imp /'}++%%'/
		{
			input->push( make_token( typeid<close_imp>, input->pull( match_length ) ) )
			restoreGlobals()
		}

		token slr / '%%' [^{] [^\n]* '\n' /
		{
			# Translates single line to multi-line
			input->pull( 2 )
			R: str = input->pull( match_length - 3 )
			input->push( "\n}%%" )
			input->push( R )
			input->push( "%%{" )
		}

		rl NL / '\n' /

		rl s_literal
			/ "'" ([^'\\\n] | '\\' (any | NL))* "'" /

		rl d_literal
			/ '"' ([^"\\] | NL | '\\' (any | NL))* '"' /

		literal `define `=

		token ident /ident "'"?/
		token number /digit+/
		token hex_number /'0x' [0-9a-fA-F]+/

		token comment
			/ ruby_comment /

		token string
			/ s_literal | d_literal | host_re_literal /

		token whitespace
			/ ( [ \t] | NL )+ /

		token c_any / any /
	end

	token no_match //

	def tok
		[no_match ident whitespace number] :ImportNum
	|	[no_match ident whitespace string] :ImportStr
	|	[no_match ident] :Else
	|	[`define whitespace ident whitespace? number]  :ImportDefNum
	|	[`define whitespace ident whitespace? string]  :ImportDefStr
	|	[ident whitespace? `= whitespace? number]      :ImportAssignNum
	|	[ident whitespace? `= whitespace? string]      :ImportAssignStr
	|	[`define]              :Def
	|	[`=]                   :Eq
	|	[ident] :Ident
	|	[number] :Number
	|	[hex_number] :HexNumber
	|	[comment] :Comment
	|	[string] :String
	|	[whitespace] :Whitespace
	|	[c_any] :Any
		{
			NM: no_match = make_token( typeid<no_match>, "" )
			I: ident = make_token( typeid<ident>, $lhs.c_any )
			lhs = cons tok [NM I]
		}

	def section
		[`%%{ ragel::opt_machine_name ragel::ign_want ragel::statement* ragel::`}%%] :MultiLine
	|	[`%%{ ragel::opt_machine_name ragel::ign_ignore consume::tok* consume::`}%%] :Consume
	|	[tok] :Token
end

lex
	token selectt /''/
	{
		input->push( make_token( typeid<c_select_section>, '' ) )
	}

	token c_select_section //
end

def start
	[c_select_section SectionList: host::section*]


reduction TopLevel
	# def inline_block
	#	[block_item_list] :List
	inline::inline_block
	{
		InlineList *inlineList;
	}

	inline::inline_block :List
	{
		$$->inlineList = $block_item_list->inlineList;
	}

	# def block_item_list
	# 	[block_item block_item_list] :Rec
	# |	[] :Base
	inline::block_item_list
	{
		InlineList *inlineList;
	}

	inline::block_item_list :Rec
	{
		$$->inlineList = $_block_item_list->inlineList;

		if ( $block_item->inlineItem != 0 )
			$$->inlineList->prepend( $block_item->inlineItem );
		else if ( $block_item->inlineList != 0 ) {
			$$->inlineList->prepend( *$block_item->inlineList );
			delete $block_item->inlineList;
		}
	}

	inline::block_item_list :Base
	{
		$$->inlineList = new InlineList;
	}
	
	# def block_item
	#	[expr_any] :ExprAny
	# |	[block_symbol] :BlockSymbol
	# |	[block_interpret] :BlockInterpret
	# |	[`{ inline_block `}] :RecBlock
	inline::block_item
	{
		InlineItem *inlineItem;
		InlineList *inlineList;
	}

	inline::block_item :ExprAny
	{
		$$->inlineItem = $expr_any->inlineItem;
	}

	inline::block_item :BlockSymbol
	{
		$$->inlineItem = $block_symbol->inlineItem;
	}

	inline::block_item :BlockInterpret
	{
		$$->inlineItem = $block_interpret->inlineItem;
	}

	inline::block_item :RecBlock
	{
		$$->inlineList = $inline_block->inlineList;
		$$->inlineList->prepend( new InlineItem( @1, "{", InlineItem::Text ) );
		$$->inlineList->append( new InlineItem( @1, "}", InlineItem::Text ) );
		$$->inlineItem = 0;
	}

	# def expr_any
	#	[whitespace] :WS
	#|	[comment] :Comment
	#|	[string] :String
	#|	[number] :Number
	#|	[hex_number] :Hex
	#|	[ident] :Ident
	#|	[c_any] :Any
	inline::expr_any
	{
		InlineItem *inlineItem;
	}

	inline::expr_any :WS
	{
		string data( $whitespace->data, $whitespace->length );
		$$->inlineItem = new InlineItem( @whitespace, data, InlineItem::Text );
	}
		
	inline::expr_any :Comment
	{
		string data( $comment->data, $comment->length );
		$$->inlineItem = new InlineItem( @comment, data, InlineItem::Text );
	}

	inline::expr_any :String
	{
		string data( $string->data, $string->length );
		$$->inlineItem = new InlineItem( @string, data, InlineItem::Text );
	}

	inline::expr_any :Number
	{
		string data( $number->data, $number->length );
		$$->inlineItem = new InlineItem( @number, data, InlineItem::Text );
	}

	inline::expr_any :Hex
	{
		string data( $hex_number->data, $hex_number->length );
		$$->inlineItem = new InlineItem( @hex_number, data, InlineItem::Text );
	}

	inline::expr_any :Ident
	{
		string data( $ident->data, $ident->length );
		$$->inlineItem = new InlineItem( @ident, data, InlineItem::Text );
	}

	inline::expr_any :Any
	{
		string data( $c_any->data, $c_any->length );
		$$->inlineItem = new InlineItem( @c_any, data, InlineItem::Text );
	}

	# def block_symbol
	#	[`,] :B1 | [`;] :B2 | [`(] :B3 | [`)] :B4 | [`*] :B5 | [`::] :B6
	inline::block_symbol
	{
		InlineItem *inlineItem;
	}

	inline::block_symbol :B1
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	inline::block_symbol :B2
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	inline::block_symbol :B3
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	inline::block_symbol :B4
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	inline::block_symbol :B5
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	inline::block_symbol :B6
	{
		string data( $1->data, $1->length );
		$$->inlineItem = new InlineItem( @1, data, InlineItem::Text );
	}

	# def block_interpret
	#	[expr_interpret] :ExprInterpret
	# |	[`fhold whitespace? `;] :Fhold
	# |	[`fgoto whitespace? `* inline_expr `;] :FgotoExpr
	# |	[`fnext whitespace? `* inline_expr `;] :FnextExpr
	# |	[`fcall whitespace? `* inline_expr `;] :FcallExpr
	# |	[`fncall whitespace? `* inline_expr `;] :FncallExpr
	# |	[`fexec inline_expr `;] :Fexec
	# |	[`fgoto state_ref srlex::`;] :FgotoSr
	# |	[`fnext state_ref srlex::`;] :FnextSr
	# |	[`fcall state_ref srlex::`;] :FcallSr
	# |	[`fncall state_ref srlex::`;] :FncallSr
	# |	[`fret `;] :Fret
	# |	[`fnret `;] :Fnret
	# |	[`fbreak `;] :Fbreak
	# |	[`fnbreak `;] :Fnbreak
	inline::block_interpret
	{
		InlineItem *inlineItem;
	}

	inline::block_interpret :Fhold
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Hold );
	}
	inline::block_interpret :FgotoExpr
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::GotoExpr );
		$$->inlineItem->children = $inline_expr->inlineList;
	}
	inline::block_interpret :FnextExpr
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::NextExpr );
		$$->inlineItem->children = $inline_expr->inlineList;
	}
	inline::block_interpret :FcallExpr
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::CallExpr );
		$$->inlineItem->children = $inline_expr->inlineList;
	}
	inline::block_interpret :FncallExpr
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::NcallExpr );
		$$->inlineItem->children = $inline_expr->inlineList;
	}
	inline::block_interpret :Fexec
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Exec );
		$$->inlineItem->children = $inline_expr->inlineList;
	}
	inline::block_interpret :FgotoSr
	{
		$$->inlineItem = new InlineItem( @1,
				$state_ref->nameRef, InlineItem::Goto );
	}
	inline::block_interpret :FnextSr
	{
		$$->inlineItem = new InlineItem( @1,
				$state_ref->nameRef, InlineItem::Next );
	}
	inline::block_interpret :FcallSr
	{
		$$->inlineItem = new InlineItem( @1,
				$state_ref->nameRef, InlineItem::Call );
	}
	inline::block_interpret :FncallSr
	{
		$$->inlineItem = new InlineItem( @1,
				$state_ref->nameRef, InlineItem::Ncall );
	}
	inline::block_interpret :Fret
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Ret );
	}
	inline::block_interpret :Fnret
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Nret );
	}
	inline::block_interpret :Fbreak
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Break );
	}
	inline::block_interpret :Fnbreak
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Nbreak );
	}

	inline::block_interpret :ExprInterpret
	{
		$$->inlineItem = $expr_interpret->inlineItem;
	}

	# def inline_expr
	# 	[expr_item_list] :List
	inline::inline_expr
	{
		InlineList *inlineList;
	}

	inline::inline_expr :List
	{
		$$->inlineList = $expr_item_list->inlineList;
	}

	# def expr_item_list
	#	[expr_item_list expr_item] :Rec
	# |	[] :Empty
	inline::expr_item_list
	{
		InlineList *inlineList;
	}

	inline::expr_item_list :Rec
	{
		$$->inlineList = $_expr_item_list->inlineList;
		$$->inlineList->append( $expr_item->inlineItem );
	}

	inline::expr_item_list :Empty
	{
		$$->inlineList = new InlineList;
	}

	# def expr_item
	# 	[expr_any] :ExprAny
	# |	[expr_symbol] :ExprSymbol
	# |	[expr_interpret] :ExprInterpret
	inline::expr_item
	{
		InlineItem *inlineItem;
	}

	inline::expr_item :ExprAny
	{
		$$->inlineItem = $expr_any->inlineItem;
	}
	inline::expr_item :ExprSymbol
	{
		string sym( $expr_symbol->sym );
		$$->inlineItem = new InlineItem( &$expr_symbol->loc, sym, InlineItem::Text );
	}
	inline::expr_item :ExprInterpret
	{
		$$->inlineItem = $expr_interpret->inlineItem;
	}

	# def expr_symbol
	#	[`,] | [`(] | [`)] | [`*] | [`::]
	inline::expr_symbol
	{
		const char *sym;
		colm_location loc;
	}

	inline::expr_symbol :Comma 
		{ $$->loc = *@1; $$->sym = ","; }
	inline::expr_symbol :Open 
		{ $$->loc = *@1; $$->sym = "("; }
	inline::expr_symbol :Close 
		{ $$->loc = *@1; $$->sym = ")"; }
	inline::expr_symbol :Star 
		{ $$->loc = *@1; $$->sym = "*"; }
	inline::expr_symbol :DoubleColon
		{ $$->loc = *@1; $$->sym = "::"; }


	# def expr_interpret
	#	[`fpc] :Fpc
	# |	[`fc] :Fc
	# |	[`fcurs] :Fcurs
	# |	[`ftargs]  :Ftargs
	# |	[`fentry `( state_ref srlex::`)] :Fentry
	# |	[var_ref] :VarRef
	inline::expr_interpret
	{
		InlineItem *inlineItem;
	}

	inline::expr_interpret :Fpc
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::PChar );
	}

	inline::expr_interpret :Fc
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Char );
	}

	inline::expr_interpret :Fcurs
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Curs );
	}

	inline::expr_interpret :Ftargs
	{
		$$->inlineItem = new InlineItem( @1, InlineItem::Targs );
	}

	inline::expr_interpret :Fentry
	{
		$$->inlineItem = new InlineItem( @1, $state_ref->nameRef, InlineItem::Entry );
	}

	inline::expr_interpret :VarRef
	{
		string data( $1->data + 1, $1->length - 1 );
		$$->inlineItem = new InlineItem( @1, InlineItem::Subst );

		ActionParamList::Iter api = *paramList;
		for ( ; api.lte(); api++ ) {
			if ( (*api)->name == data )
				break;
		}

		if ( api.end() )
			pd->id->error( @1 ) << "invalid parameter reference \"$" << $1->data << "\"" << endl;
		else {
			$$->inlineItem->substPos = api.pos();
		}
	}


	# Pass Through.
	# def tok
	#	[`define ident number] :Def1
	# |	[`define ident string] :Def2
	# |	[ident `= number]      :Ass1
	# |	[ident `= string]      :Ass2
	#	[`define whitespace ident whitespace? number]  :ImportDefNum
	# |	[`define whitespace ident whitespace? string]  :ImportDefStr
	# |	[ident whitespace? `= whitespace? number]      :ImportAssignNum
	# |	[ident whitespace? `= whitespace? string]      :ImportAssignStr
	# |	[`define]              :Def
	# |	[`=]                   :Eq
	# |	[ident] :Ident
	# |	[number] :Number
	# |	[hex_number] :HexNumber
	# |	[comment] :Comment
	# |	[string] :String
	# |	[whitespace] :Whitespace
	# |	[c_any] :Any

	host::tok  :ImportDefNum
	{
		if ( isImport )
		{
			Literal *lit = new Literal( @number,
					false /* $number->neg */, $number->data,
					$number->length, Literal::Number );

			string name( $ident->data, $ident->length );
			import( @ident, name, lit );
		}
		else
		{
			if ( includeDepth == 0 ) {
				id->curItem->data.write( "define ", 7 );
				id->curItem->data.write( $ident->data, $ident->length );
				id->curItem->data.write( " ", 1 );
				id->curItem->data.write( $number->data, $number->length );
			}
		}
	}
	host::tok  :ImportDefStr
	{
		if ( isImport )
		{
			Literal *lit = new Literal( @string, false,
					$string->data, $string->length, Literal::LitString );
			string name( $ident->data, $ident->length );
			import( @ident, name, lit );
		}
		else
		{
			if ( includeDepth == 0 ) {
				id->curItem->data.write( "define ", 7 );
				id->curItem->data.write( $ident->data, $ident->length );
				id->curItem->data.write( " ", 1 );
				id->curItem->data.write( $string->data, $string->length );
			}
		}
	}
	host::tok  :ImportAssignNum
	{
		if ( isImport )
		{
			Literal *lit = new Literal( @number,
					false /*$number->neg */, $number->data,
					$number->length, Literal::Number );
			string name( $ident->data, $ident->length );
			import( @ident, name, lit );
		}
		else
		{
			if ( includeDepth == 0 ) {
				id->curItem->data.write( $ident->data, $ident->length );
				id->curItem->data.write( "=", 1 );
				id->curItem->data.write( $number->data, $number->length );
			}
		}
	}
	host::tok  :ImportAssignStr
	{
		if ( isImport )
		{
			Literal *lit = new Literal( @string, false,
					$string->data, $string->length, Literal::LitString );

			string name( $ident->data, $ident->length );
			import( @ident, name, lit );
		}
		else
		{
			if ( includeDepth == 0 ) {
				id->curItem->data.write( $ident->data, $ident->length );
				id->curItem->data.write( "=", 1 );
				id->curItem->data.write( $string->data, $string->length );
			}
		}
	}
	host::tok  :Def
	{
		if ( !isImport && includeDepth == 0 )
			id->curItem->data.write( "define", 6 );

	}
	host::tok  :Eq
	{
		if ( !isImport && includeDepth == 0 )
			id->curItem->data.write( "=", 1 );
	}

	host::tok :Ident
	{
		if ( !isImport && includeDepth == 0 )
			id->curItem->data.write( $ident->data, $ident->length );
	}

	host::tok :Number
	{
		if ( !isImport && includeDepth == 0 )
			id->curItem->data.write( $number->data, $number->length );
	}

	host::tok :HexNumber
	{
		if ( !isImport && includeDepth == 0 )
			id->curItem->data.write( $hex_number->data, $hex_number->length );
	}

	host::tok :Comment
	{
		if ( !isImport && includeDepth == 0 )
			id->curItem->data.write( $comment->data, $comment->length );
	}

	host::tok :String
	{
		if ( !isImport && includeDepth == 0 )
			id->curItem->data.write( $string->data, $string->length );
	}

	host::tok :Whitespace
	{
		if ( !isImport && includeDepth == 0 )
			id->curItem->data.write( $whitespace->data, $whitespace->length );
	}

	host::tok :Any
	{
		if ( !isImport && includeDepth == 0 )
			id->curItem->data.write( $c_any->data, $c_any->length );
	}
	host::tok :Else
	{
		if ( !isImport && includeDepth == 0 )
			id->curItem->data.write( $ident->data, $ident->length );
	}

	host::section :MultiLine
	{
		if ( !isImport && includeDepth == 0 ) {
			InputItem *inputItem = new InputItem;
			inputItem->type = InputItem::EndSection;
			inputItem->loc = @5;
			id->inputItems.append( inputItem );

			if ( section != 0 ) {
				inputItem->section = section;
				section->lastReference = inputItem;
			}

			/* The end section may include a newline on the end, so
			 * we use the last line, which will count the newline. */
			inputItem = new InputItem;
			inputItem->type = InputItem::HostData;
			inputItem->loc = @5;
			if ( inputItem->loc.fileName == 0 )
				inputItem->loc = @1;
						
			id->inputItems.append( inputItem );

			/* Record the parse data and move over the end section. */
			id->curItem = id->curItem->next;
			id->curItem->pd = pd;

			/* Move over the host data. */
			id->curItem = id->curItem->next;
		}
	}

end
