# Or-literal scanner
lex
	token orlit_dash /'-' /
	token orlit_close /']'/

	rl orlit_specials /[\-\]]/
	token orlit_chr /^orlit_specials | '\\' any/
end

def orlit_item 
	[orlit_chr]
|	[orlit_chr orlit_dash orlit_chr]

def orlit 
	[orlit_item*]

# Regex scanner
lex
	token orlit_open /'['/
	token orlit_neg_open /'[^'/
	token regex_dot /'.'/
	token regex_star /'*'/
	token regex_close /'/'/

	rl regex_specials /[\[\.\*\/\\]/
	token regex_chr /(^regex_specials)+ | '\\' any/
end

def regex_rep 
	[regex_star]
|	[]

def regex_base 
	[regex_chr]
|	[regex_dot]
|	[orlit_open orlit orlit_close]
|	[orlit_neg_open orlit orlit_close]

def regex_item 
	[regex_base regex_rep]

def regex_body
	[regex_item*]

rl s_string /"'" ([^'\\\n] | '\\' any )* "'"/
rl d_string /'"' ([^"\\\n] | '\\' any )* '"'/

# Root scanner
lex
	token ident /[a-zA-Z_]+/
	token number /[0-9]+/
	token string /s_string | d_string/

	literal '+', '-', '*', ';', '/'
	token slash /'/'/
	token semi /';'/

	ignore wp /[ \t\n]+/
end

def factor 
	[ident]
|	[number]
|	[string]
|	['/' regex_body regex_close]

def term 
	[term '*' factor]
|	[term '/' factor]
|	[factor]

def expr 
	[expr '+' term]
|	[expr '-' term]
|	[term]

def statement 
	[expr ';']

def start 
	[statement*]


parse SP: start[ stdin ]
S: start = SP.tree

for I:orlit_item in S {
	if match I [orlit_chr] {
		print( I '\n' )
	}
}
print_xml( S )
print( '\n' )
