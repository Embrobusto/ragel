include 'trans.lm'

OutputFile: str = argv.pop()
InputFile: str = argv.pop()
Lang: str = argv.pop()

Input: stream = open( InputFile "r" )
Output: stream = open( OutputFile "w" )

RagelTree: start = parse start[ Input ]

if ( !RagelTree ) {
	print( error '\n' )
	exit(1)
}

# Find the machine name.
MachineName: ragel::machine_name = ragel::machine_name in RagelTree

# Do we need EOF?
NeedsEof: bool = false
for CommVal: comm_val in RagelTree {
	if $CommVal ==
		'@NEEDS_EOF: yes\n'
	{
		NeedsEof = true
	}
}

prints( Output
	"/*
	" * @LANG: go
	" * @GENERATED: yes
	" */
	"
	"package main
	"import \"fmt\"
	"
)

int indepToHost( Indep: ref<section*> )
{
	for Decl: var_decl in Indep {
		if match Decl
			"bool [Ident: tk_ident OptArr: opt_arr];
		{
			Decl = cons var_decl
				"var [Ident] [OptArr] int
		}
		elsif match Decl
			"int [Ident: tk_ident OptArr: opt_arr];
		{
			Decl = cons var_decl
				"var [Ident] [OptArr] int
		}
		elsif match Decl
			"char [Ident: tk_ident OptArr: opt_arr];
		{
			Decl = cons var_decl
				"var [Ident] [OptArr] byte
		}
		elsif match Decl
			"ptr [Ident: tk_ident];
		{
			Decl = cons var_decl
				"var [Ident] int
		}
	}

	for Tok: tok in Indep {
		if match Tok "true"
			Tok = cons tok "1"
		elsif match Tok "false"
			Tok = cons tok "0"
		elsif match Tok ['<' type '>' '(' TokList: tok* ')']
			Tok = cons tok ['(' Tok.type ')' '(' TokList ')']
		elsif match Tok ['printi' V: tok ';' ] {
			cons VL: tok*[V]
			Tok = cons tok[ "fmt.Print( [V] );"]
		}
		elsif match Tok ['printb' V: tok ';' ] {
			cons VL: tok*[V]
			Tok = cons tok[ "fmt.Print( string ( [V]\[:pos\] ));"]
		}
		elsif match Tok ['prints' V: tok ';' ] {
			cons VL: tok*[V]
			Tok = cons tok[ "fmt.Print( [V] );"]
		}
		elsif match Tok ['print_token' ';' ] {
			Tok = cons tok[ "fmt.Print( data\[ts:te\] );" ]
		}
		elsif match Tok ['first_token_char'] {
			Tok = cons tok ["data\[ts\]"]
		}
	}
}

for Section: section in RagelTree {
	if match Section [Decl: var_decl] {
		cons SectionList: section* [Decl]
		indepToHost( SectionList )
		prints( Output SectionList )
	}
}

for Section: section in RagelTree {
	if match Section [section_multiline] {
		for Action: ragel::action_block in Section {
			# Reparse as lang-independent code.
			parse SectionList: section*[$Action]

			# Translate to specific language.
			indepToHost( SectionList )

			# Reparse back to ragel action block.
			Action = parse ragel::action_block[$SectionList]
		}

		prints( Output '\n' Section '\n' )
	}
}

send Output
	"var cs int
	"
	"%% write data;
	"
	"func prepare() {

for Section: section in RagelTree {
	if match Section [ExprStmt: expr_stmt] {
		cons SectionList: section* [ExprStmt]
		indepToHost( SectionList )
		prints( Output SectionList )
	}
}

send Output
	"	%% write init;
	"}
	"
	"func exec(data string) {
    "	var p int = 0
    "	var pe int = len(data)

if NeedsEof {
	send Output
		"	var eof int = pe
}

send Output
	"	%% write exec;
	"}
	"func finish() {
	"	if cs >= [MachineName.word]_first_final {
	"		fmt.Println(\"ACCEPT\")
	"	} else {
	"		fmt.Println(\"FAIL\")
	"	}
	"}

send Output
	~var inp []string = []string {

for InputString: input_string in RagelTree {
	send Output [^InputString ",\n"]
}

send Output
	"};
	"

send Output
	"func main() {
	"	for _, data := range inp {
	"		prepare()
	"		exec(data)
	"		finish()
	"	}
	"}

send Output "/* _____OUTPUT_____
for OutputLine: output_line in RagelTree {
	prints( Output OutputLine )
}
send Output "*/
