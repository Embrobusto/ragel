
lex start
{
	ignore /[\t\n ]+/
	literal '^', '|', '-', ',', ':', '!', '?', '.'
	literal '(', ')', '{', '}', '*', '&', '+'

	literal '--', ':>', ':>>', '<:', '->', '**'

	literal ':=', '=', ';'

	literal 'machine', 'action'

		token string /
			'"' any* :> '"' |
			"'" any* :> "'"
		/
	token word /[a-zA-Z_][a-zA-Z0-9_]*/
	token uint /[0-9]+/
}

def expression [term expression_op*]

def expression_op
	['|' term]
|	['&' term]
|	['-' term]
|	['--' term]

def term [factor_rep term_op_list_short]

# This list is done manually to get shortest match.
def term_op_list_short
	[]
|	[term_op term_op_list_short]

def term_op
	[factor_rep]
|	['.' factor_rep]
|	[':>' factor_rep]
|	[':>>' factor_rep]
|	['<:' factor_rep]

def factor_rep 
	[factor_neg factor_rep_op*]

def factor_rep_op
	['*']
|	['**']
|	['?']
|	['+']
|	['{' factor_rep_num '}']
|	['{' ',' factor_rep_num '}']
|	['{' factor_rep_num ',' '}']
|	['{' factor_rep_num ',' factor_rep_num '}']

def factor_rep_num
	[uint]

def factor_neg 
	['!' factor_neg]
|	['^' factor_neg]
|	[factor]

def factor 
	[alphabet_num]
|	[word]
|	[string]
|	['(' expression ')']

def alphabet_num 
	[uint]
|	['-' uint]

def machine_def
	[word '=' expression ';']
|	[word ':=' expression ';']
|	['machine' word ';']
|	['action' word '{' host::tok+ '}']

def ragel_start 
	[machine_def*]

namespace host
{
	lex host
	{
		literal '%%', '%%{', '}%%'

		token comment /'/*' any* :>> '*/'/
		token ws /[ \t\n]+/

		token string /
			'"' any* :> '"' |
			"'" any* :> "'"
		/

		token sym /
			';'
		/

		token word /[a-zA-Z_][a-zA-Z0-9_]*/
		token uint /[0-9]+/
	}

	def tok
		[word]
	|	[uint]
	|	[comment]
	|	[string]
	|	[sym]
	|	[ws]

	def section
		['%%' ws '%%{' ragel_start '}%%']
	|	[tok+]
}

def start
	[host::section*]

parse Start: start[ stdin ]

if Start.tree
	print( Start.tree '\n' )
else
	print( Start.error '\n' )
