include '../src/ragel.lm'

namespace indep_host
	lex 
		literal '%%{', '}%%'
		literal 'int', 'bool', 'char', 'ptr', 'printi', 'prints', 'printf'

		literal ';', '<', '>', '(', ')'

		ignore / ( [ \t] | NL )+ /

		rl NL / '\n' /

		rl s_literal
			/ "'" ([^'\\] | NL | '\\' (any | NL))* "'" /

		rl d_literal
			/ '"' ([^"\\] | NL | '\\' (any | NL))* '"' /

		rl INPUT /'_'+ 'INPUT' '_'+/
		rl OUTPUT /'_'+ 'OUTPUT' '_'+/

		token input_id / INPUT /

		token ident /ident/
		token number /digit+/
		token hex_number /'0x' [0-9a-fA-F]+/

		token output
			/ '/*' ' '* OUTPUT any* :>> ( OUTPUT ' '* '*/' ) /

		token comment
			/ c_comment | cpp_comment /

		token string
			/ s_literal | d_literal /

		token indep_any / any /
	end

	def input_string
		[string]

	def input_list
		[input_list input_string]
	| 	[input_string]

	def input
		[input_id input_list input_id]

	def tok
		[ident]
	|	[number]
	|	[hex_number]
	|	[input]
	|	[output]
	|	[comment]
	|	[string]
	|	['<' type '>' '(' tok* ')']
	|	['(' tok* ')']
	|	['printi' tok ';']
	|	['prints' tok ';']
	|	['printf' '(' tok* ')' ';']
	|	[indep_any]
	|	[';']
	|	['<']
	|	['>']

	def section_multiline
		['%%{' ragel::ragel_start '}%%']

	def type
		['int'] | ['bool'] | ['char'] | ['ptr']

	def var_decl
		[type ident ';']

	def stmt
		[var_decl]

	def section
		[section_multiline]
	|	[stmt]
	|	[tok]
end

OutputFile: str = argv.pop()
InputFile: str = argv.pop()
Lang: str = argv.pop()

def start
	[indep_host::section*]

Input: stream = open( InputFile "r" )
Output: stream = open( OutputFile "w" )

RagelTree: start = parse start[ Input ]

if ( !RagelTree ) {
	print( error '\n' )
	exit(1)
}

prints( Output
	"/*
	" * @LANG: [Lang]
	" * @GENERATED: yes
	" */
	"
	"#include <string.h>
	"#include <stdio.h>
	"
)

int indepToHost( Indep: ref<indep_host::section*> )
{
	for Decl: indep_host::var_decl in Indep {
		if match Decl
			"bool [Ident: indep_host::ident];
		{
			Decl = cons indep_host::var_decl
				"int [Ident];
		}
	}

	for Tok: indep_host::tok in Indep {
		if match Tok "true"
			Tok = cons indep_host::tok "1"
		elsif match Tok "false"
			Tok = cons indep_host::tok "0"
		elsif match Tok [indep_host::'<' indep_host::type indep_host::'>' indep_host::'(' TokList: indep_host::tok* indep_host::')']
			Tok = cons indep_host::tok [indep_host::'(' TokList indep_host::')']
		elsif match Tok [indep_host::'printi' V: indep_host::tok indep_host::';' ] {
			cons VL: indep_host::tok*[V]
			Tok = cons indep_host::tok[ "printf( \"%d\", [V] );"]
		}
		elsif match Tok [indep_host::'prints' V: indep_host::tok indep_host::';' ] {
			cons VL: indep_host::tok*[V]
			Tok = cons indep_host::tok[ "printf( \"%s\", [V] );"]
		}
			
	}
}

for Section: indep_host::section in RagelTree {
	if match Section [Decl: indep_host::var_decl] {
		cons SectionList: indep_host::section* [Decl]
		indepToHost( SectionList )
		prints( Output SectionList )
	}
}

for Section: indep_host::section in RagelTree {
	if match Section [indep_host::section_multiline] {
		for Action: ragel::action_block in Section {
			# Reparse as lang-independent code.
			parse SectionList: indep_host::section*[$Action]

			# Translate to specific language.
			indepToHost( SectionList )

			# Reparse back to ragel action block.
			Action = parse ragel::action_block[$SectionList]
		}

		prints( Output '\n' Section '\n' )
	}
}

prints( Output
	"int cs;
	"
	"%% write data;
	"
	"void init()
	"{
)

prints( Output
	"	%% write init;
	"}
	"
	"void exec( char *data, int len )
	"{
	"	char *p = data;
	"	char *pe = data + len;
	"	char *eof = pe;
	"	%% write exec;
	"}
	"
	"void finish( )
	"{
	"	if ( cs >= AtoI_first_final )
	"		printf( \"ACCEPT\\n\" );
	"	else
	"		printf( \"FAIL\\n\" );
	"}
	"
)

prints( Output
	"char *inp\[\] = {
)

NR: int = 0
for InputString: indep_host::input_string in RagelTree {
	prints( Output ^InputString ',\n' )
	NR = NR + 1
}

prints( Output
	"};
	"
)

prints( Output "int inplen = " NR ";\n\n" )

prints( Output
	"int main( )
	"{
	"	int i;
	"	for ( i = 0; i < inplen; i++ ) {
	"		init();
	"		exec( inp\[i\], strlen(inp\[i\]) );
	"		finish();
	"	}
	"	return 0;
	"}
	"
)

for Section: indep_host::section in RagelTree {
	if match Section [OutputBlock: indep_host::output]
		prints( Output OutputBlock )
}
