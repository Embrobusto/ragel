include 'trans.lm'

namespace c
	lex 
		literal `%%{ `}%%

		literal `int `bool `const `char 
				`printf `fwrite

		literal `; `< `> `( `) `[ `] `=
				`* `! `{ `} `+ `- `== `!= `,

		ignore / ( [ \t] | NL )+ /

		token tk_ident /ident/
		token tk_number /digit+/
		token tk_hex_number /'0x' [0-9a-fA-F]+/

		token string
			/ s_literal | d_literal /
	end

	def factor
		[tk_ident]
	|	[tk_ident `[ expr `]]
	|	[tk_number]
	|	[tk_hex_number]
	|	[string]
	|	[`( type `) `( expr `)]
	|	[`( expr `)]

	def op
		[`<] | [`>] | [`=] | [`!]
	|	[`+] | [`-] | [`*] | [`!=]
	|	[`==] | [`,]

	def expr_op
		[op factor]

	def expr
		[factor expr_op*]

	def opt_arr
		[`[ expr `]]
	|	[]

	def type
		[`int]
	|	[`bool]
	|	[`char]
	|	[`char `*]
	|	[`const `( `char `) `*]

	def var_decl
		[type tk_ident opt_arr `;]

	def print_stmt
		[`printf `( expr `) `;]
	|	[`fwrite `( expr `) `;]
end

namespace out_code
	lex
		token line
			/[^\n]* '\n'/
	end

	def lines
		[line*]

	alias line_parser
		parser<lines>
end

global Out: parser<out_code::lines> =
		cons parser<out_code::lines> []

int rw_c_factor( Factor: indep::factor )
{
	if match Factor [`first_token_char]
	{
	}
	else if match Factor [tk_ident `[ expr `]]
	{
	}
	else if match Factor [tk_ident `( expr `)]
	{
	}
	elsif match Factor [`< type `> `( expr `)]
	{
	}
	elsif match Factor [`( expr `)]
	{
	}
	else 
	{
		send Out [$Factor]
	}
}

void rw_c_type( Type: indep::type )
{
	if match Type [`int]
	{
		send Out "int"
	}
	elsif match Type [`bool]
	{
		send Out "int"
	}
	elsif match Type [`char]
	{
		send Out "char"
	}
	elsif match Type [`ptr]
	{
		send Out "char *"
	}
	elsif match Type [`byte]
	{
		send Out "unsigned char"
	}
}

void rw_c_expr_op( Expr: indep::expr_op )
{
#	if match ExprOp [op expr_op]
#	elsif match ExprOp [
}

void rw_c_expr( Expr: indep::expr )
{
	rw_c_factor( Expr.factor )
#	for ExprOp: indep::expr_op in repeat(Expr.ExprOpList)
#		rw_c_factor( ExprOp.factor )
}

void rw_c_opt_array( OptArr: indep::opt_arr )
{
	if OptArr.expr {
		send Out "\[[$rw_c_expr( OptArr.expr )]\]"
	}
}

int rw_c_var_decl( VarDecl: indep::var_decl )
{
	send Out
		"[$rw_c_type( VarDecl.type )] [$VarDecl.tk_ident][$rw_c_opt_array(VarDecl.opt_arr)];
}

int rw_c_expr_stmt( ExprStmt: indep::expr_stmt )
{
#	print( "expr_stmt\n" )
	if match ExprStmt [tk_ident opt_sub `= expr `;]
	{
	}
	else if match ExprStmt [expr `;]
	{
	}
}

int rw_c_if_stmt( ExprStmt: indep::if_stmt )
{
#	print( "if_stmt\n" )
}

int rw_c_print_stmt( Stmt: indep::print_stmt )
{
#	print( "print_stmt\n" )
	if match Stmt [`print_int expr `;]
	{
	}
	else if match Stmt [`print_buf expr `, expr `;]
	{
	}
	else if match Stmt [`print_str expr `;]
	{
	}
	else if match Stmt [`print_token `;]
	{
	}
}

int rw_c_ragel_stmt( Stmt: indep::ragel_stmt )
{
#	print( "ragel_stmt\n" )
	if match Stmt [`fgoto tk_ident `;]
	{
	}
	else if match Stmt [`fcall tk_ident `;]
	{
	}
	else if match Stmt [`fnext tk_ident `;]
	{
	}
	else if match Stmt [`fgoto `* expr `;]
	{
	}
	else if match Stmt [`fcall `* expr `;]
	{
	}
	else if match Stmt [`fnext `* expr `;]
	{
	}
	else if match Stmt [`fexec expr `;]
	{
	}
}

int rw_stmt( Stmt: indep::stmt )
{
#	print( "stmt\n" )

	if match Stmt [var_decl]
	{
#		print( "var_decl\n" )
		rw_c_var_decl( Stmt.var_decl )
	}
	else if match Stmt [expr_stmt]
	{
#		print( "expr_stmt\n" )
		rw_c_expr_stmt( Stmt.expr_stmt )
	}
	else if match Stmt [if_stmt]
	{
#		print( "if_stmt\n" )
		rw_c_if_stmt( Stmt.if_stmt )
	}
	else if match Stmt [print_stmt]
	{
#		print( "print_stmt\n" )
		rw_c_print_stmt( Stmt.print_stmt )
	}
	else if	match Stmt [ragel_stmt]
	{
#		print( "ragel_stmt\n" )
		rw_c_ragel_stmt( Stmt.ragel_stmt )
	}
}

int rw_c_stmt_list( StmtList: indep::stmt* )
{
#	print( "stmt_list\n" )
	for Stmt: indep::stmt in repeat( StmtList )
		rw_stmt( Stmt )
}

int rw_c_action_block( ActionBlock: indep::action_block )
{
	Out = cons parser<out_code::lines> []
	if match ActionBlock [`{ stmt* `}] {
		rw_c_stmt_list( ActionBlock._repeat_stmt )
	}
	else if match ActionBlock [`{ expr `}] {
		rw_c_expr( ActionBlock.expr )
	}
	send Out 'hello\n' eos
}

namespace indep

c::factor c_factor( Factor: factor )
{
	return cast<c::factor> Factor
}

c::tk_ident c_ident( Ident: tk_ident )
{
	return cast<c::tk_ident> Ident
}

c::opt_arr c_opt_arr( OptArr: opt_arr )
{
	return cast<c::opt_arr> OptArr
}

c::expr c_expr( Expr: expr )
{
	return cast<c::expr> Expr
}

int c_rewrite( Indep: ref<any> )
{
	for Factor: factor in Indep {
		if match Factor "true" {
			Factor = cons factor "1"
		}
		elsif match Factor "false" {
			Factor = cons factor "0"
		}
		elsif match Factor 
				['<' type '>' '(' Expr: expr ')']
		{
			Factor = cast<factor> cons c::factor 
				"( [c_expr(Expr)] )
		}
		elsif match Factor ['first_token_char'] {
			Factor = cast<factor> cons c::factor
				"ts\[0\]"
		}
	}

	for Decl: var_decl in Indep {
		if match Decl
			"bool [Ident: tk_ident OptArr: opt_arr];
		{
			Decl = cast<var_decl> cons c::var_decl
				"int [c_ident(Ident)] [c_opt_arr(OptArr)];
		}
		elsif match Decl
			"ptr [Ident: tk_ident];
		{
			Decl = cast<var_decl> cons c::var_decl
				"char* [c_ident(Ident)];
		}
	}

	for Stmt: print_stmt in Indep {
		if match Stmt ['print_int' F: factor ';' ] {
			Stmt = cast<print_stmt> cons c::print_stmt
				"printf( \"%d\", [c_factor(F)] );"
		}
		elsif match Stmt ['print_buf' F: factor ',' L: tk_ident ';' ] {
			Stmt = cast<print_stmt> cons c::print_stmt
				"fwrite( [c_factor(F)], 1, [c_ident(L)], stdout );"
		}
		elsif match Stmt ['print_str' F: factor ';' ] {
			Stmt = cast<print_stmt> cons c::print_stmt
				"printf( \"%s\", [c_factor(F)] );"
		}
		elsif match Stmt ['print_token' ';' ] {
			Stmt = cast<print_stmt> cons c::print_stmt
				"fwrite ( ts , 1 , te - ts , stdout );" 
		}
	}
}

end


OutputFile: str = argv.pop()
InputFile: str = argv.pop()
Lang: str = argv.pop()

Input: stream = open( InputFile "r" )
Output: stream = open( OutputFile "w" )

RagelTree: indep::start = parse indep::start[ Input ]

if ( !RagelTree ) {
	print( error '\n' )
	exit(1)
}

# Find the machine name.
MachineName: ragel::machine_name = ragel::machine_name in RagelTree

# Do we need EOF?
NeedsEof: bool = false
for CommVal: indep::comm_val in RagelTree {
	if $CommVal ==
		'@NEEDS_EOF: yes\n'
	{
		NeedsEof = true
	}
}

send Output
	"/*
	" * @LANG: [Lang]
	" * @GENERATED: yes
	" */
	"
	"#include <string.h>
	"#include <stdio.h>
	"

Init: indep::stmt* = RagelTree.Init
for Stmt: indep::stmt in Init {
	if match Stmt [Decl: var_decl] {
		rw_c_var_decl( Decl )
		c_rewrite( Decl )
		send Output [Decl]
	}
}

Section: indep::section = RagelTree.section
for Action: ragel::action_block in Section {
	# Reparse as lang-independent code.
	parse IndepActionBlock: indep::action_block[$Action]
	if ( !IndepActionBlock ) {
		print( error '\n' Action )
		exit(1)
	}

	#rw_c_action_block( IndepActionBlock )
	#print( Out.tree )

	# Translate to specific language.
	c_rewrite( IndepActionBlock )

	# Reparse back to ragel action block.
	Action = parse ragel::action_block[$IndepActionBlock]
	if ( !Action ) {
		print( error '\n' )
		exit(1)
	}
}

send Output
	"
	"[Section]
	"
	"%% write data;
	"int cs;
	"
	"void init()
	"{

for Stmt: indep::stmt in Init {
	if match Stmt [ExprStmt: expr_stmt] {
		rw_c_expr_stmt( ExprStmt )
		c_rewrite( ExprStmt )
		send Output [ExprStmt]
	}
}

send Output
	"	%% write init;
	"}
	"
	"void exec( char *data, int len )
	"{
	"	char *p = data;
	"	char *pe = data + len;

if NeedsEof {
	send Output
		"	char *eof = pe;
}

send Output
	"	%% write exec;
	"}
	"
	"void finish( )
	"{
	"	if ( cs >= [$MachineName.word]_first_final )
	"		printf( \"ACCEPT\\n\" );
	"	else
	"		printf( \"FAIL\\n\" );
	"}
	"

send Output
	"char *inp\[\] = {

NR: int = 0
for InputString: indep::input_string in RagelTree {
	send Output 
		[^InputString ",\n"]
	NR = NR + 1
}

send Output
	"};
	"

send Output
	"int inplen = [NR];
	"

send Output
	"int main( )
	"{
	"	int i;
	"	for ( i = 0; i < inplen; i++ ) {
	"		init();
	"		exec( inp\[i\], strlen(inp\[i\]) );
	"		finish();
	"	}
	"	return 0;
	"}
	"

send Output "/* _____OUTPUT_____
for OutputLine: indep::output_line in RagelTree {
	send Output [OutputLine]
}
send Output "*/
